{
  "Swagger Init file": {
    "prefix": "swag-init",
    "body": [
      "import swaggerAutogen from \"swagger-autogen\";",
      "",
      "const output = \"./swagger.json\";",
      "const endpoints = [\"./routes/*.*\"];",
      "",
      "const doc = {",
      "  openapi: \"3.0.0\",",
      "  info: {",
      "    title: \"${1:title}\",",
      "    version: \"${2:1.0.0}\",",
      "    description:",
      "      \"${3:description}\",",
      "    contact: {",
      "      name: \"${4:name}\",",
      "      email: \"${5:email}\",",
      "      url: \"${6:website}\",",
      "    },",
      "    license: {",
      "      name: \"Licensed Under MIT\",",
      "      url: \"https://spdx.org/licenses/MIT.html\",",
      "    },",
      "  },",
      "  servers: [",
      "    {",
      "      url: \"${7:url-production-server}\",",
      "      description: \"Prod Server\",",
      "    },",
      "    {",
      "      url: \"${8:url-development-server}\",",
      "      description: \"Dev Server\",",
      "    },",
      "  ],",
      "  securityDefinitions: {",
      "    api_key: {",
      "      type: \"apiKey\",",
      "      name: \"api_key\",",
      "      in: \"header\",",
      "    },",
      "  },",
      "  tags: [${9:tags}],",
      "  security: [",
      "    {",
      "      bearerAuth: [],",
      "    },",
      "  ],",
      "  components: {",
      "    schemas: {",
      "      ${10:entries}",
      "    },",
      "  },",
      "};",
      "",
      "swaggerAutogen(output, endpoints, doc)"
    ],
    "description": "Swagger Init file"
  },
  "Swagger Request Multipart": {
    "prefix": "swag-request-multipart",
    "body": [
      "/* #swagger.requestBody = {",
      "    \"@content\": {",
      "        \"multipart/form-data\": {",
      "            schema: { ",
      "                type: 'object',",
      "                properties: {",
      "                    ${1}",
      "                }",
      "            }",
      "        }",
      "    }",
      "} */"
    ],
    "description": "Swagger Request Multipart"
  },
  "Swagger Tag & Description": {
    "prefix": "swag-tag",
    "body": [
      "/* #swagger.tags = ['${1:tagName}']",
      "   #swagger.description = '${2:description}' */"
    ],
    "description": "Swagger Tag & Description"
  },
  "Swagger Response ": {
    "prefix": "swag-resp",
    "body": [
      "// #swagger.responses[${1:statCode}] = { description: '${2:desc}' }"
    ],
    "description": "Swagger Response "
  },
  "Swagger Response w/ Schema": {
    "prefix": "swag-resp-sch",
    "body": [
      "/* #swagger.responses[${1:statCode}] = {",
      "    content: {",
      "      \"application/json\": {",
      "        schema: { \\$ref: \"#/components/schemas/${2:schemaName}\" }",
      "      }",
      "    }, ",
      "    description: '${3:description}' ",
      "} */"
    ],
    "description": "Swagger Response w/ Schema"
  },
  "Swagger Parameters": {
    "prefix": "swag-param",
    "body": [
      "/* #swagger.parameters['${1:name}'] = {",
      "    in: '${2|query,path|}',",
      "    description: '${3:desc}',",
      "    ${4:required:true}${5:}",
      "} */"
    ],
    "description": "Swagger Parameters"
  },
  "Swagger Request": {
    "prefix": "swag-request",
    "body": [
      "/* #swagger.requestBody = {",
      "      content: {",
      "        \"application/json\": {",
      "          schema: { \\$ref: \"#/components/schemas/${1:name}\" }",
      "        }",
      "      }",
      "  } */"
    ],
    "description": "Swagger Request"
  },
  "Swagger Schema": {
    "prefix": "swag-sche",
    "body": [
      "schema: { \"\\$ref\": \"#/components/schemas/${1:schemaName}\" }"
    ],
    "description": "Swagger Schema"
  },
  "Express Websocket": {
    "prefix": "exp-websocket",
    "body": [
      "import Websocket from \"ws\";",
      "",
      "const wss = new Websocket.Server({ server: server });",
      "",
      "wss.on(\"connection\", (ws) => {",
      "  ",
      "});"
    ],
    "description": "Express Websocket"
  },
  "Typeorm database client": {
    "prefix": "typeorm-cl",
    "body": [
      "import { DataSource } from \"typeorm\";",
      "import dotenv from \"dotenv\";",
      "dotenv.config();",
      "",
      "const connectdb = new DataSource({",
      "  url: process.env.DATABASE_URL,",
      "  type: \"postgres\",",
      "  entities: [__dirname + \"/../entities/*\"],",
      "  synchronize: true,",
      "  extra: {",
      "    ssl: false,",
      "  },",
      "});",
      "",
      "export const mintdb = async () => {",
      "  try {",
      "    await connectdb.initialize();",
      "    console.log(\"Connected to database\");",
      "  } catch (error) {",
      "    console.log(error);",
      "  }",
      "};",
      ""
    ],
    "description": "Typeorm database client"
  },
  "Utils Ethers Listener": {
    "prefix": "utils-eth-list",
    "body": [
      "import { ethers } from \"ethers\";",
      "import usdtABI from \"./abi.json\";",
      "import * as dotenv from 'dotenv';",
      "dotenv.config()",
      "",
      "export const ethEvenListener = async () => {",
      "  const usdtAddress = process.env.CONT_ADDR;",
      "",
      "  const provider = new ethers.JsonRpcProvider(",
      "    `https://goerli.infura.io/v3/${process.env.INFURA}`",
      "  );",
      "",
      "  const contract = new ethers.Contract(usdtAddress, usdtABI, provider);",
      "",
      "};"
    ],
    "description": "Utils Ethers Listener"
  },
  "Utils Ethers Listener fn": {
    "prefix": "utils-eth-list-fn",
    "body": [
      "contract.on(\"${1:name}\", ${2:async} (${3:params}) => {",
      "  ${4}",
      "});"
    ],
    "description": "Utils Ethers Listener fn"
  },
  "Graph Shield Rule": {
    "prefix": "graph-sh-rule",
    "body": [
      "const ${1:name} = rule()(",
      "  async (_parent: any, args: any, context: any) => {",
      "    ${2}",
      "  }",
      ");"
    ],
    "description": "Graph Shield Rule"
  },
  "Ethers Event Listener": {
    "prefix": "eth-listen",
    "body": [
      "import dotenv from \"dotenv\";",
      "import { ethers } from \"ethers\";",
      "import abi from \"./abis/Shoalin.json\";",
      "",
      "dotenv.config();",
      "",
      "const infura = `wss://goerli.infura.io/ws/v3/${process.env.INFURA}`;",
      "",
      "(async () => {",
      "  const addr = \"0x9758553D373C072EF30c851ed6f732B8C27010b4\";",
      "  const provider = new ethers.WebSocketProvider(infura);",
      "",
      "  const contract = new ethers.Contract(",
      "    addr,",
      "    JSON.parse(JSON.stringify(abi)),",
      "    provider",
      "  );",
      "})();"
    ],
    "description": "Ethers Event Listener"
  },
  "Graph Shield Input": {
    "prefix": "graph-sh-input",
    "body": [
      "const ${1:name} = inputRule()((yup) =>",
      "  yup.object({",
      "    ${2}",
      "  })",
      ");"
    ],
    "description": "Graph Shield Input"
  },
  "Graph Shield": {
    "prefix": "graph-sh",
    "body": [
      "import { rule, shield } from \"graphql-shield\";",
      "",
      "const permissions = shield({",
      "  Query: {",
      "    ",
      "  },",
      "  Mutation: {",
      "    ",
      "  },",
      "});",
      "",
      "export default permissions;"
    ],
    "description": "Graph Shield"
  },
  "Graph Resolver": {
    "prefix": "graph-resolve",
    "body": [
      "${1:name}: (_parent: ${2:any}, args: ${3:any}, context: ${4:any}) => {",
      "  ${5}",
      "},"
    ],
    "description": "Graph Resolver"
  },
  "Graph Resolver Union": {
    "prefix": "graph-resolve-union",
    "body": [
      "${1:name}: {",
      "  __resolveType: (object: any) => {",
      "    ${2}",
      "    return null;",
      "  };",
      "}"
    ],
    "description": "Graph Resolver Union"
  },
  "Redux Store": {
    "prefix": "rdx-store",
    "body": [
      "import { configureStore } from \"@reduxjs/toolkit\";",
      "",
      "export const store = configureStore({",
      "  reducer: {},",
      "  devTools: process.env.NODE_ENV !== \"production\",",
      "});",
      "",
      "export type RootState = ReturnType<typeof store.getState>;"
    ],
    "description": "Redux Store"
  },
  "Express Graphql": {
    "prefix": "exp-graphql",
    "body": [
      "import express, { Application } from \"express\";",
      "import { graphqlHTTP } from \"express-graphql\";",
      "import { applyMiddleware } from \"graphql-middleware\";",
      "import permissions from \"./permissions\";",
      "import { schema } from \"./utils/schema.utils\";",
      "import config from \"config\";",
      "import depthLimit from \"graphql-depth-limit\";",
      "",
      "const schemaWithPermissions = applyMiddleware(schema, permissions);",
      "",
      "const app: Application = express();",
      "",
      "app.use(",
      "  config.get(\"graphEndPoint\"),",
      "  graphqlHTTP({",
      "    schema: schemaWithPermissions,",
      "    graphiql: {",
      "      headerEditorEnabled: true,",
      "    },",
      "    validationRules: [depthLimit(4)],",
      "  })",
      ");",
      "",
      "export default app;",
      ""
    ],
    "description": "Express Graphql"
  },
  "Next Apollo Client": {
    "prefix": "nxt-apollo-client",
    "body": [
      "import {",
      "  ApolloClient,",
      "  ApolloLink,",
      "  InMemoryCache,",
      "  NormalizedCacheObject,",
      "} from '@apollo/client'",
      "import { onError } from '@apollo/link-error'",
      "import { createUploadLink } from 'apollo-upload-client'",
      "import merge from 'deepmerge'",
      "import { IncomingHttpHeaders } from 'http'",
      "import fetch from 'isomorphic-unfetch'",
      "import isEqual from 'lodash/isEqual'",
      "import type { AppProps } from 'next/app'",
      "import { useMemo } from 'react'",
      "import { paginationField } from './paginationField'",
      "",
      "const APOLLO_STATE_PROP_NAME = '__APOLLO_STATE__'",
      "",
      "let apolloClient: ApolloClient<NormalizedCacheObject> | undefined",
      "",
      "const createApolloClient = (headers: IncomingHttpHeaders | null = null) => {",
      "  // isomorphic fetch for passing the cookies along with each GraphQL request",
      "  const enhancedFetch = (url: RequestInfo, init: RequestInit) => {",
      "    return fetch(url, {",
      "      ...init,",
      "      headers: {",
      "        ...init.headers,",
      "        'Access-Control-Allow-Origin': '*',",
      "        // here we pass the cookie along for each request",
      "        Cookie: headers?.cookie ?? '',",
      "      },",
      "    }).then((response) => response)",
      "  }",
      "",
      "  return new ApolloClient({",
      "    // SSR only for Node.js",
      "    ssrMode: typeof window === 'undefined',",
      "    link: ApolloLink.from([",
      "      onError(({ graphQLErrors, networkError }) => {",
      "        if (graphQLErrors)",
      "          graphQLErrors.forEach(({ message, locations, path }) =>",
      "            console.log(",
      "              `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`",
      "            )",
      "          )",
      "        if (networkError)",
      "          console.log(",
      "            `[Network error]: ${networkError}. Backend is unreachable. Is it running?`",
      "          )",
      "      }),",
      "      // this uses apollo-link-http under the hood, so all the options here come from that package",
      "      createUploadLink({",
      "        uri: `${1:http://localhost:3000/api/graphql}`,",
      "        // Make sure that CORS and cookies work",
      "        fetchOptions: {",
      "          mode: 'cors',",
      "        },",
      "        credentials: 'include',",
      "        fetch: enhancedFetch,",
      "      }),",
      "    ]),",
      "    cache: new InMemoryCache(),",
      "  })",
      "}",
      "",
      "type InitialState = NormalizedCacheObject | undefined",
      "",
      "interface IInitializeApollo {",
      "  headers?: IncomingHttpHeaders | null",
      "  initialState?: InitialState | null",
      "}",
      "",
      "export const initializeApollo = (",
      "  { headers, initialState }: IInitializeApollo = {",
      "    headers: null,",
      "    initialState: null,",
      "  }",
      ") => {",
      "  const _apolloClient = apolloClient ?? createApolloClient(headers)",
      "",
      "  // If your page has Next.js data fetching methods that use Apollo Client, the initial state",
      "  // get hydrated here",
      "  if (initialState) {",
      "    // Get existing cache, loaded during client side data fetching",
      "    const existingCache = _apolloClient.extract()",
      "",
      "    // Merge the existing cache into data passed from getStaticProps/getServerSideProps",
      "    const data = merge(initialState, existingCache, {",
      "      // combine arrays using object equality (like in sets)",
      "      arrayMerge: (destinationArray, sourceArray) => [",
      "        ...sourceArray,",
      "        ...destinationArray.filter((d) =>",
      "          sourceArray.every((s) => !isEqual(d, s))",
      "        ),",
      "      ],",
      "    })",
      "",
      "    // Restore the cache with the merged data",
      "    _apolloClient.cache.restore(data)",
      "  }",
      "",
      "  // For SSG and SSR always create a new Apollo Client",
      "  if (typeof window === 'undefined') return _apolloClient",
      "  // Create the Apollo Client once in the client",
      "  if (!apolloClient) apolloClient = _apolloClient",
      "",
      "  return _apolloClient",
      "}",
      "",
      "export const addApolloState = (",
      "  client: ApolloClient<NormalizedCacheObject>,",
      "  pageProps: AppProps['pageProps']",
      ") => {",
      "  if (pageProps?.props) {",
      "    pageProps.props[APOLLO_STATE_PROP_NAME] = client.cache.extract()",
      "  }",
      "",
      "  return pageProps",
      "}",
      "",
      "export function useApollo(pageProps: AppProps['pageProps']) {",
      "  const state = pageProps[APOLLO_STATE_PROP_NAME]",
      "  const store = useMemo(() => initializeApollo({ initialState: state }), [",
      "    state,",
      "  ])",
      "  return store",
      "}"
    ],
    "description": "Next Apollo Client"
  },
  "Redux Store Persist": {
    "prefix": "rdx-store-pers",
    "body": [
      "import { combineReducers, configureStore } from \"@reduxjs/toolkit\";",
      "import {",
      "  persistReducer,",
      "  persistStore,",
      "  FLUSH,",
      "  REHYDRATE,",
      "  PAUSE,",
      "  PERSIST,",
      "  PURGE,",
      "  REGISTER,",
      "  PersistConfig,",
      "} from \"redux-persist\";",
      "import storage from \"redux-persist/lib/storage\";",
      "",
      "const rootReducer = combineReducers({",
      "    ",
      "});",
      "",
      "const persistConfig: PersistConfig<any> = {",
      "  key: \"${1:key}\",",
      "  storage,",
      "  whitelist: [],",
      "};",
      "",
      "const persistedReducer = persistReducer(persistConfig, rootReducer);",
      "",
      "export const store = configureStore({",
      "  reducer: persistedReducer,",
      "  devTools: process.env.NODE_ENV !== \"production\",",
      "  middleware: (getDefaultMiddleware) =>",
      "    getDefaultMiddleware({",
      "      serializableCheck: {",
      "        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],",
      "      },",
      "    }),",
      "});",
      "",
      "export const persistor = persistStore(store);",
      "",
      "export type RootState = ReturnType<typeof store.getState>;",
      ""
    ],
    "description": "Redux Store Persist"
  },
  "Redux Slice": {
    "prefix": "rdx-slice",
    "body": [
      "import { createSlice } from \"@reduxjs/toolkit\";",
      "",
      "const initialState = {};",
      "",
      "export const ${1:sliceName} = createSlice({",
      "  name: \"${2:name}\",",
      "  initialState,",
      "  reducers: {},",
      "});",
      "",
      "export const {} = ${1:sliceName}.actions;",
      "export default ${1:sliceName}.reducer;"
    ],
    "description": "Redux Slice"
  },
  "Redux Async": {
    "prefix": "rdx-async",
    "body": [
      "import { Dispatch } from \"@reduxjs/toolkit\";",
      "import { AxiosInstance } from \"axios\";",
      "import { isAxiosError } from \"../api/axios\";",
      "",
      "export const fetchPosts = async (",
      "  axiosInstance: AxiosInstance,",
      "  dispatch: Dispatch",
      ") => {",
      "  try {",
      "",
      "  } catch (error) {",
      "    const err = isAxiosError(error);",
      "",
      "  }",
      "};"
    ],
    "description": "Redux Async"
  },
  "Generate JWT utils": {
    "prefix": "utils-tokens",
    "body": [
      "import jwt from \"jsonwebtoken\";",
      "import dotenv from \"dotenv\";",
      "dotenv.config();",
      "",
      "type UserType = {",
      "  id: string;",
      "  roles: string;",
      "};",
      "",
      "export const generateAccess = (user: UserType, expires: string) => {",
      "  return jwt.sign(",
      "    {",
      "      id: user.id,",
      "      roles: user.roles,",
      "    },",
      "    process.env.ACCESS_SECRET as string,",
      "    {",
      "      expiresIn: expires,",
      "    }",
      "  );",
      "};",
      "",
      "export const generateRefresh = (user: UserType, expires: string) => {",
      "  return jwt.sign(",
      "    {",
      "      id: user.id,",
      "      role: user.roles,",
      "    },",
      "    process.env.REFRESH_SECRET as string,",
      "    {",
      "      expiresIn: expires,",
      "    }",
      "  );",
      "};",
      "",
      "export const getMaxAge = (time: string) => {",
      "  let unit;",
      "  let duration: any;",
      "",
      "  if (isNaN(time as any)) {",
      "    unit = time[time.length - 1];",
      "    duration = time.length > 1 ? time.substring(0, time.length - 1) : time[0];",
      "  } else {",
      "    duration = time;",
      "  }",
      "",
      "  if (isNaN(duration)) return null;",
      "",
      "  switch (unit) {",
      "    case \"h\":",
      "      return parseInt(duration) * 60 * 60 * 1000;",
      "    case \"m\":",
      "      return parseInt(duration) * 60 * 1000;",
      "    case \"s\":",
      "      return parseInt(duration) * 1000;",
      "    default:",
      "      return parseInt(duration);",
      "  }",
      "};"
    ],
    "description": "Generate JWT utils"
  },
  "Auth Utils": {
    "prefix": "utils-auth",
    "body": [
      "import bcrypt from \"bcryptjs\";",
      "",
      "export const hashPassword = (password: string) => {",
      "  return new Promise((resolve, reject) => {",
      "    bcrypt.genSalt(10, (err, salt) => {",
      "      if (err) {",
      "        reject(err);",
      "      }",
      "",
      "      bcrypt.hash(password, salt, (err, hash) => {",
      "        if (err) {",
      "          reject(err);",
      "        }",
      "        resolve(hash);",
      "      });",
      "    });",
      "  });",
      "};",
      "",
      "export const comparePasswords = (password: string, hashPassword: string) => {",
      "  return bcrypt.compare(password, hashPassword);",
      "};",
      ""
    ],
    "description": "Auth Utils"
  },
  "Next Lib Auth": {
    "prefix": "nxt-lib-auth",
    "body": [
      "import { add, parseISO } from \"date-fns\";",
      "",
      "export const getMaxAge = (value: string) => {",
      "  if (value === \"\") return \"\";",
      "",
      "  let time = value;",
      "  const unit = time.charAt(time.length - 1);",
      "  time = time.substring(0, time.length - 1);",
      "  const options: Duration = {};",
      "",
      "  switch (unit) {",
      "    case \"s\":",
      "      options.seconds = parseInt(time);",
      "      break;",
      "    case \"m\":",
      "      options.minutes = parseInt(time);",
      "      break;",
      "    case \"h\":",
      "      options.hours = parseInt(time);",
      "      break;",
      "    case \"d\":",
      "      options.days = parseInt(time);",
      "      break;",
      "    default:",
      "      break;",
      "  }",
      "",
      "  return add(new Date(), options).toISOString();",
      "};",
      "",
      "export const isExpired = (maxAge: string) => {",
      "  const now = new Date();",
      "  const parseMax = parseISO(maxAge);",
      "",
      "  if (parseMax > now) return false;",
      "  else return true;",
      "};",
      ""
    ],
    "description": "Next Lib Auth"
  },
  "Winston Logger": {
    "prefix": "utils-winston",
    "body": [
      "import winston, { LoggerOptions } from \"winston\";",
      "",
      "let configz: LoggerOptions | undefined;",
      "",
      "const {",
      "  format: { combine, timestamp, printf, colorize },",
      "  createLogger,",
      "  format,",
      "  transports,",
      "} = winston;",
      "",
      "////////////////////////////////////",
      "/// Formatter",
      "const formatter = combine(",
      "  timestamp({ format: \"YYYY-MM-DD HH:mm:ss\" }),",
      "  printf(({ level, message, timestamp }) => {",
      "    return `[\\${level}]: \\${timestamp} - \\${message}`;",
      "  }),",
      "  format.json()",
      ");",
      "",
      "const formatter2 = combine(",
      "  colorize(),",
      "  printf(({ level, message }) => {",
      "    return `[\\${level}]: \\${message}`;",
      "  })",
      ");",
      "",
      "////////////////////////////////////",
      "/// Configz",
      "const devConf = {",
      "  level: \"debug\",",
      "  format: formatter2,",
      "  transports: [new transports.Console()],",
      "};",
      "",
      "const mainConf = {",
      "  level: \"info\",",
      "  format: formatter,",
      "  transports: [new transports.File({ filename: \"./logs/sys.log\" })],",
      "};",
      "",
      "////////////////////////////////////",
      "///",
      "if (process.env.NODE_ENV !== \"production\") configz = devConf;",
      "else configz = mainConf;",
      "",
      "const logger = createLogger(configz);",
      "",
      "export default logger;",
      ""
    ],
    "description": "Winston Logger"
  },
  "Express Yup Schema": {
    "prefix": "exp-schema",
    "body": [
      "import * as yup from \"yup\";",
      "",
      "export const ${1:schemaName} = yup.object({",
      "  ",
      "});",
      "",
      "export type ${1:schemaName}Type = yup.TypeOf<typeof ${1:schemaName}>;"
    ],
    "description": "Express Yup Schema"
  },
  "Express Yup Validate Middleware": {
    "prefix": "middle-vSchema",
    "body": [
      "/* eslint-disable @typescript-eslint/no-explicit-any */",
      "import { Request, Response, NextFunction } from \"express\";",
      "import { ObjectShape, OptionalObjectSchema } from \"yup/lib/object\";",
      "",
      "export default (",
      "  schema: OptionalObjectSchema<ObjectShape>,",
      "  type: \"body\" | \"query\" | \"params\"",
      ") => {",
      "  return async (req: Request, res: Response, next: NextFunction) => {",
      "    try {",
      "      switch (type) {",
      "        case \"query\":",
      "          await schema.validate(req.query);",
      "          break;",
      "        case \"body\":",
      "          await schema.validate(req.body);",
      "          break;",
      "        case \"params\":",
      "          await schema.validate(req.params);",
      "          break;",
      "      }",
      "    } catch (error: any) {",
      "      return res.status(400).json({ error: error.message });",
      "    }",
      "    next();",
      "  };",
      "};",
      ""
    ],
    "description": "Express Yup Validate Middleware"
  },
  "Express Control Auth": {
    "prefix": "exp-ctl-auth",
    "body": [
      "/* eslint-disable @typescript-eslint/no-explicit-any */",
      "import { Request, Response, NextFunction } from \"express\";",
      "import { comparePasswords, hashPassword } from \"../utils/auth.utils\";",
      "import { generateAccess, getMaxAge } from \"../utils/token.utils\";",
      "import config from \"config\";",
      "",
      "////////////////////////////////////",
      "/// Register",
      "export const postRegister = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// Login",
      "export const postLogin = async (req: Request, res: Response) => {",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// Refresh",
      "export const getRefresh = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  const { token } = res.locals.token;",
      "  const { user } = req.query;",
      "",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// Logout",
      "export const getLogout = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  const token = req.headers.cookie?.match(config.get(\"cookieName\"));",
      "  if (!token) return res.sendStatus(204);",
      "",
      "  const { user } = req.query;",
      "  const tokn = token?.input?.split(\"=\")[1] as string;",
      "",
      "  return res.sendStatus(204);",
      "};"
    ],
    "description": "Express Control Auth"
  },
  "Express JWT BEARER Validate Middleware": {
    "prefix": "middle-jwt-bearer",
    "body": [
      "import { Request, Response, NextFunction } from \"express\";",
      "import jsonwebtoken from \"jsonwebtoken\";",
      "",
      "export default (req: Request, res: Response, next: NextFunction) => {",
      "  const reqHead = req.headers.authorization || req.headers.Authorization;",
      "  if (!reqHead)",
      "    return res.status(401).json({ error: \"Missing Authorization header\" });",
      "  try {",
      "    const token = req.headers.authorization?.split(\" \")[1] as string;",
      "    const decoded = jsonwebtoken.verify(",
      "      token,",
      "      process.env.${1:ACCESS_SECRET} as string",
      "    );",
      "    res.locals.user = decoded;",
      "    next();",
      "  } catch (err) {",
      "    return res.sendStatus(401);",
      "  }",
      "};",
      ""
    ],
    "description": "Express JWT BEARER Validate Middleware"
  },
  "Express JWT COOKIE Validate Middleware": {
    "prefix": "middle-jwt-cookie",
    "body": [
      "import express, { Request, Response, NextFunction } from \"express\";",
      "import jwt from \"jsonwebtoken\";",
      "import config from \"config\";",
      "",
      "export default (req: Request, res: Response, next: NextFunction) => {",
      "  const token = req.headers.cookie?.match(config.get(\"cookieName\"));",
      "  if (!token) return res.status(403).json({ error: \"Missing refresh cookie\" });",
      "",
      "  const tokn = token?.input?.split(\"=\")[1] as string;",
      "",
      "  try {",
      "    const decoded = jwt.verify(tokn, process.env.${1:REFRESH_SECRET} as string);",
      "",
      "    res.locals.token = Object.assign(decoded, {}, { token: tokn });",
      "    next();",
      "  } catch (err) {",
      "    return res.sendStatus(403);",
      "  }",
      "};",
      ""
    ],
    "description": "Express JWT COOKIE Validate Middleware"
  },
  "Express Role Validate Middleware": {
    "prefix": "middle-vRole",
    "body": [
      "import { Request, Response, NextFunction } from \"express\";",
      "",
      "export default (...allowRoles: any) => {",
      "  return (req: Request, res: Response, next: NextFunction) => {",
      "    if (!res.locals.user.roles) return res.sendStatus(401);",
      "    const rolesArray = [...allowRoles];",
      "    console.log(rolesArray);",
      "    console.log(res.locals.user.roles);",
      "    const result = res.locals.user?.roles",
      "      .map((role: number) => rolesArray.includes(role))",
      "      .find((val: any) => val === true);",
      "    if (!result) return res.sendStatus(401);",
      "    next();",
      "  };",
      "};",
      ""
    ],
    "description": "Express Role Validate Middleware"
  },
  "Express Request": {
    "prefix": "exp-req",
    "body": ["const ${2:value} = req.${1|body,params,query|}"],
    "description": "Express Request"
  },
  "Express Request Try": {
    "prefix": "trycr",
    "body": [
      "try {",
      "      ",
      "} catch (error: any) {",
      "  logger.error(error);",
      "  return next(new Error(\"Internal Server Error\"));",
      "}"
    ],
    "description": "Express Request Try"
  },
  "Express CORS": {
    "prefix": "exp-cors",
    "body": [
      "app.use((req:Request, res:Response, next: NextFunction) => {",
      "    const allowedOrigins = ['http://127.0.0.1:8020', 'http://localhost:8020', 'http://127.0.0.1:9000', 'http://localhost:9000'];",
      "    const origin = req.headers.origin;",
      "    if (allowedOrigins.includes(origin as string) || !origin) {",
      "         res.setHeader('Access-Control-Allow-Origin', origin as string);",
      "    }",
      "    else {",
      "       logger.error(`CORS blocked for \\${origin}`);",
      "    }",
      "    res.header(",
      "        'Access-Control-Allow-Headers',",
      "        'Accept, Origin, Authorization, Content-Type, X-Requested-With'",
      "    );",
      "    if (req.method === 'OPTIONS') {",
      "        res.header('Access-Control-Allow-Methods','PUT, GET, POST, DELETE, PATCH');",
      "        return res.status(200).json({})",
      "    }",
      "    res.header('Access-Control-Allow-Credentials', \"true\");",
      "    next();",
      "});"
    ],
    "description": "Express CORS"
  },
  "Express Server": {
    "prefix": "exp-server",
    "body": [
      "/* eslint-disable @typescript-eslint/no-explicit-any */",
      "import app from \"./app\";",
      "import http from \"http\";",
      "import dotenv from \"dotenv\";",
      "import logger from \"./utils/logger.utils\";",
      "dotenv.config();",
      "",
      "const PORT = process.env.PORT",
      "",
      "const server = http.createServer(app);",
      "",
      "const feedback = () => {",
      "  logger.debug(${1:`Swagger Docs @ /docs`})",
      "};",
      "",
      "server.listen(PORT, feedback);"
    ],
    "description": "Express Server"
  },
  "App Reducer": {
    "prefix": "app-reducer",
    "body": [
      "import { getMaxAge } from \"@/lib/auth\";",
      "",
      "export type authType = {",
      "  id: string;",
      "  maxAge: string;",
      "  roles: number[];",
      "};",
      "",
      "export type StateType = {",
      "  auth: authType;",
      "};",
      "",
      "////////////////////////////////////",
      "/// States",
      "",
      "export const initialState: StateType = {",
      "  auth: {",
      "    id: \"\",",
      "    maxAge: \"\",",
      "    roles: [],",
      "  },",
      "};",
      "",
      "////////////////////////////////////",
      "/// Actions",
      "",
      "export type MaxAgeActionType = {",
      "  type: \"SET_MAX_AGE\";",
      "  payload: string;",
      "};",
      "",
      "export type RolesActionType = {",
      "  type: \"SET_ROLES\";",
      "  payload: number[];",
      "};",
      "",
      "export type IDActionType = {",
      "  type: \"SET_ID\";",
      "  payload: string;",
      "};",
      "",
      "export type ActionType = IDActionType | MaxAgeActionType | RolesActionType;",
      "",
      "////////////////////////////////////",
      "/// Reducer",
      "",
      "export const AppReducer = (state: StateType, action: ActionType) => {",
      "  switch (action.type) {",
      "    case \"SET_ID\":",
      "      return {",
      "        ...state,",
      "        auth: Object.assign(state.auth, {}, { id: action.payload }),",
      "      };",
      "    case \"SET_MAX_AGE\":",
      "      return {",
      "        ...state,",
      "        auth: Object.assign(",
      "          state.auth,",
      "          {},",
      "          { maxAge: getMaxAge(action.payload) }",
      "        ),",
      "      };",
      "    case \"SET_ROLES\":",
      "      return {",
      "        ...state,",
      "        auth: Object.assign(state.auth, {}, { roles: action.payload }),",
      "      };",
      "    default:",
      "      return initialState;",
      "  }",
      "};",
      ""
    ],
    "description": "App Reducer"
  },
  "App Reducer Action": {
    "prefix": "app-reducer-act",
    "body": [
      "export type ${1:name} = {",
      "    type: ${2:type},",
      "    payload: ${3:payload}",
      "}"
    ],
    "description": "App Reducer Action"
  },
  "Next OnDemand ISR": {
    "prefix": "nxt-isr-ond",
    "body": [
      "import { NextApiRequest, NextApiResponse } from \"next\";",
      "",
      "export default async function handler(",
      "  req: NextApiRequest,",
      "  res: NextApiResponse",
      ") {",
      "  const { token } = req.query;",
      "",
      "  if (token !== process.env.REVALIDATE_TOKEN)",
      "    return res.status(401).json({ error: \"Unauthorized to update page\" });",
      "",
      "  try {",
      "    await res.revalidate(`${1:path}`);",
      "    return res.status(204);",
      "  } catch (err) {",
      "    return res.status(400).json({ error: err });",
      "  }",
      "}"
    ],
    "description": "Next OnDemand ISR"
  },
  "Next Middleware": {
    "prefix": "nxt-middle",
    "body": [
      "import { NextRequest, NextResponse } from \"next/server\";",
      "",
      "export async function middleware(req: NextRequest) {",
      "  ${2:}",
      "  ",
      "  return NextResponse.next();",
      "}",
      "",
      "export const config = {",
      "  matcher: [\"${1:/api/users/:path*}\"],",
      "};"
    ],
    "description": "Next Middleware"
  },
  "Express App": {
    "prefix": "exp-app",
    "body": [
      "import express, {Application, Request, Response, NextFunction} from 'express';",
      "import path from 'path';",
      "import fs from 'fs';",
      "import morgan from 'morgan';",
      "",
      "const app:Application = express();",
      "",
      "app.set('x-powered-by', false);",
      "",
      "app.use(express.${1|json,urlencoded|}());",
      "",
      "////////////////////////////////////",
      "/// Static files & Logs",
      "if(process.env.MODE == 'PRO') {",
      "    app.use(express.static(path.join(__dirname, 'public')))",
      "",
      "    const accessLogStream = fs.createWriteStream(",
      "      path.join(__dirname, 'accessLog'),",
      "      { flags: 'a' }",
      "    );",
      "    app.use(morgan('combined', { stream: accessLogStream }))",
      "}",
      "else if(process.env.MODE == 'DEV') {",
      "    app.use(express.static(path.join(__dirname, '..', 'public')))",
      "    app.use(morgan('dev'));",
      "}",
      "",
      "////////////////////////////////////",
      "/// Routes",
      "app.use((req:Request, res:Response, next: NextFunction) => {",
      "    res.status(404).send('<h1>Oops!! Resource not found</h1>')",
      "})",
      "",
      "app.use((error:Error, req:Request, res:Response, next: NextFunction) => {",
      "    res.status(500).send('<h1>Server Error: We working on it</h1>')",
      "})",
      "",
      "export default app;"
    ],
    "description": "Express App"
  },
  "Express Multipart Array Objects": {
    "prefix": "exp-multipart-arr-obj",
    "body": [
      "const ${1:fieldname}N = req.body.${1:fieldname}.split(\",\");",
      "  const ${2:name} = ${1:fieldname}N.map((item: any) => {",
      "    return JSON.parse(item);",
      "  });"
    ],
    "description": "Express Multipart Array Objects"
  },
  "Express Multipart Remove image b4 upload": {
    "prefix": "exp-multipart-rm-img",
    "body": [
      "if (${1:name}?.filename !== undefined) {",
      "  fs.unlinkSync(${1:name}?.path as string);",
      "}"
    ],
    "description": "Express Multipart Remove image b4 aws upload"
  },
  "Express router": {
    "prefix": "exp-router",
    "body": [
      "import express ${1:, {Request, Response, NextFunction\\}} from 'express';",
      "",
      "const router = express.Router();",
      "",
      "export default router;"
    ],
    "description": "Express router"
  },
  "Express route": {
    "prefix": "exp-route",
    "body": [
      "${1|app,router|}.${2|get,post,delete,put,use|}('${3:/}', ${4: async (req:Request, res:Response, next: NextFunction) => {\\}})"
    ],
    "description": "Express route"
  },
  "Express route controller": {
    "prefix": "exp-route-ctl",
    "body": [
      "////////////////////////////////////",
      "/// ${1:Comment}",
      "router.${2|get,post,delete,put|}('${3:/}', ${4: controller})"
    ],
    "description": "Express route controller"
  },
  "Express Control": {
    "prefix": "exp-ctl",
    "body": [
      "////////////////////////////////////",
      "/// ${1:Comment}",
      "export const ${2:controlName} = ${3:async}(req:Request, res:Response, ${4:next: NextFunction}) => {",
      "    ${5:Logic}",
      "}"
    ],
    "description": "Express Control"
  },
  "Express GET,PUT,DEL,POST Controller ": {
    "prefix": "exp-ctl-temp",
    "body": [
      "////////////////////////////////////",
      "/// GET /${1:resource}",
      "export const get${3:ResourceName}_All = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// GET /${1:resource}/:${2:idName}",
      "export const get${3:ResourceName} = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// POST /${1:resource}",
      "export const post${3:ResourceName} = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// PUT /${1:resource}/:${2:idName}",
      "export const put${3:ResourceName} = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  return res.sendStatus(200);",
      "};",
      "",
      "////////////////////////////////////",
      "/// DELETE /${1:resource}/:${2:idName}",
      "export const delete${3:ResourceName} = async (",
      "  req: Request,",
      "  res: Response,",
      "  next: NextFunction",
      ") => {",
      "  return res.sendStatus(200);",
      "};"
    ],
    "description": "Express GET,PUT,DEL,POST Controller "
  },
  "Return Status + message": {
    "prefix": "ret-status-mess",
    "body": ["return res.status(${1:code}).json({${value}});"],
    "description": "Return Status + message"
  },
  "Return Status": {
    "prefix": "ret-status",
    "body": ["return res.sendStatus(${1:code});"],
    "description": "Return Status"
  },
  "Express Controller": {
    "prefix": "exp-controller",
    "body": [
      "/* eslint-disable @typescript-eslint/no-explicit-any */",
      "import {Request, Response, NextFunction} from 'express';",
      "",
      "//////////////////////////////////////////////////",
      "///// Use exp-ctl command to generate template below",
      "",
      "// const controllerName = (req:Request, res:Response, next: NextFunction) => {",
      "//     Logic",
      "// }"
    ],
    "description": "Express Controller"
  },
  "Middleware file upload w/ multer": {
    "prefix": "middle-fileupload",
    "body": [
      "import { Request, Response, NextFunction } from \"express\";",
      "import fs from \"fs\";",
      "import multer from \"multer\";",
      "import { profileUpload } from \"../utils/fileupload\";",
      "// ------ Utils Fileupload Instances ---------",
      "// .single('fieldname') | for a single file",
      "// .array('fieldname', 4) | multiple files with same fieldname and max",
      "// .fields([{name: 'fieldname1', maxCount: 1}, ",
      "//       {name: 'fieldname2', maxCount: 8}]) | for multiple files with different fieldnames and max",
      "",
      "const upload = profileUpload.single('${1:fieldName}');",
      "",
      "export const ${2:middleName} = async(req: Request, res: Response, next: NextFunction) => {",
      "    const dir = \"./images/\";",
      "    if (!fs.existsSync(dir)) {",
      "      fs.mkdirSync(dir, { recursive: true });",
      "    }",
      "",
      "    upload(req, res, function (err: any) {",
      "        if (err instanceof multer.MulterError) {",
      "            // A Multer error occurred while uploading.",
      "            console.log(err.message);",
      "            return res.status(400).json({ error: err.message });",
      "        } else if (err) {",
      "            // An error occurred from multer utils.",
      "            console.log(err.message)",
      "            return res.status(400).json({ error: err.message });",
      "        }",
      "        next();",
      "    })",
      "}"
    ],
    "description": "Middleware file upload w/ multer"
  },
  "Utils AWS S3": {
    "prefix": "utils-aws-s3",
    "body": [
      "import fs from \"fs\";",
      "import {",
      "  S3Client,",
      "  PutObjectCommand,",
      "  GetObjectCommand,",
      "  DeleteObjectCommand,",
      "} from \"@aws-sdk/client-s3\";",
      "import { getSignedUrl } from \"@aws-sdk/s3-request-presigner\";",
      "import dotenv from \"dotenv\";",
      "dotenv.config();",
      "",
      "const s3 = new S3Client({",
      "  region: process.env.AWS_BUCKET_REGION,",
      "  credentials: {",
      "    accessKeyId: process.env.AWS_ACCESS_KEY as string,",
      "    secretAccessKey: process.env.AWS_SECRET_KEY as string,",
      "  },",
      "});",
      "",
      "// eslint-disable-next-line @typescript-eslint/no-explicit-any",
      "export const pushFile = (file: any) => {",
      "  const fileStream = fs.createReadStream(file.path);",
      "",
      "  const uploadParams = {",
      "    Bucket: process.env.AWS_BUCKET_NAME as string,",
      "    Body: fileStream,",
      "    Key: file.filename,",
      "  };",
      "",
      "  const command = new PutObjectCommand(uploadParams);",
      "  return s3.send(command);",
      "};",
      "",
      "export const fetchFile = (filename: string, ttl: number) => {",
      "  const getObjectParams = {",
      "    Bucket: process.env.AWS_BUCKET_NAME as string,",
      "    Key: filename,",
      "  };",
      "  const command = new GetObjectCommand(getObjectParams);",
      "  return getSignedUrl(s3, command, { expiresIn: ttl });",
      "};",
      "",
      "export const deleteFile = (filename: string) => {",
      "  const deleteObjectParams = {",
      "    Bucket: process.env.AWS_BUCKET_NAME as string,",
      "    Key: filename,",
      "  };",
      "  const command = new DeleteObjectCommand(deleteObjectParams);",
      "  return s3.send(command);",
      "};",
      ""
    ],
    "description": "Utils AWS S3"
  },
  "Mysql": {
    "prefix": "mysql-cf",
    "body": [
      "import mysql from 'mysql2/promise';",
      "import config from 'config';",
      "",
      "const db = mysql.createPool({",
      "  host: config.get(\"db_host\"),",
      "  user: config.get(\"db_user\"),",
      "  database: config.get(\"db_database\"),",
      "  password: config.get(\"db_password\"),",
      "  waitForConnections: true,",
      "  connectionLimit: 10,",
      "  queueLimit: 0",
      "});",
      "",
      "export default db;"
    ],
    "description": "Mysql"
  },
  "Mysql service": {
    "prefix": "mysql-s",
    "body": [
      "export const ${1:service} = () => {",
      "  const queryString = ``;",
      "",
      "  return db.execute(queryString, []);",
      "};"
    ],
    "description": "Mysql service"
  },
  "Mysql service2": {
    "prefix": "mysql-s2",
    "body": [
      "export const ${1:service} = (${2:params}) => {",
      "  return ${3:code}",
      "};"
    ],
    "description": "Mysql service2"
  },
  "Mysql service transaction": {
    "prefix": "mysql-t",
    "body": [
      "export const ${1:service} = async () => {",
      "  const queryString1 = ``;",
      "  const queryString2 = ``;",
      "",
      "  let connection;",
      "  try {",
      "    connection = await db.getConnection();",
      "    await connection.beginTransaction();",
      "    const result = await connection.query(queryString1, []);",
      "    ",
      "    connection.commit();",
      "    connection.release();",
      "  } catch (error: any) {",
      "    if (error.sqlMessage) connection?.rollback();",
      "    connection?.release();",
      "    return Promise.reject(error);",
      "  }",
      "};"
    ],
    "description": "Mysql service transaction"
  },
  "Mysql response & rows": {
    "prefix": "mysql-rows",
    "body": [
      "const ${1:name}Results = await ${2:method};",
      "const ${1:name} = (<RowDataPacket>${1:name}Results[0]) as ${3:type}[];"
    ],
    "description": "Mysql response & rows"
  },
  "Mysql response & ok": {
    "prefix": "mysql-ok",
    "body": [
      "const response = await ${1:method};",
      "const ok = (<OkPacket>response[0]);"
    ],
    "description": "Mysql response & ok"
  },
  "Mysql AffectedRows Response ": {
    "prefix": "mysql-res-affectrows",
    "body": [
      "if (ok.affectedRows > 0) return res.sendStatus(200);",
      "return res.status(404).json({",
      "  error: \"A record matching path variable '${1:paramName}' was not found\",",
      "});"
    ],
    "description": "Mysql AffectedRows Response "
  },
  "Mysql Placeholder Service": {
    "prefix": "mysql-plc-findby",
    "body": [
      "export const placeHolder_findBy = (",
      "  attr: string,",
      "  filter: string,",
      "  filterValues: object",
      ") => {",
      "  const queryString = `SELECT \\${attr} FROM ${1:tableName} \\${filter}`;",
      "  return db.query(queryString, { ...filterValues });",
      "};"
    ],
    "description": "Mysql Placeholder Service"
  },
  "Mysql Join": {
    "prefix": "mysql-join",
    "body": [
      "export const join = (queryString: string) => {",
      "  return db.query(queryString);",
      "};"
    ],
    "description": "Mysql Join"
  },
  "Mysql Join + Input": {
    "prefix": "mysql-join2",
    "body": [
      "export const join2 = (queryString: string, filterValues: any[]) => {",
      "  return db.query(queryString, [...filterValues]);",
      "};"
    ],
    "description": "Mysql Join + Input"
  },
  "Mysql Model": {
    "prefix": "mysql-md",
    "body": [
      "/* eslint-disable @typescript-eslint/no-explicit-any */",
      "import db from '../utils/db';",
      "",
      "export const findAll = (attr: string) => {",
      "  const queryString = `SELECT \\${attr} FROM ${1:tableName}`;",
      "  return db.execute(queryString);",
      "};",
      "",
      "export const findBy = (attr: string, filter: string, filterValues: any[]) => {",
      "  const queryString = `SELECT \\${attr} FROM ${1:tableName} \\${filter}`;",
      "  return db.execute(queryString, [...filterValues]);",
      "};",
      "",
      "export const update = (setFilter: string, filterValues: any[]) => {",
      "  const queryString = `UPDATE ${1:tableName} \\${setFilter}`;",
      "  return db.execute(queryString, [...filterValues]);",
      "};",
      "",
      "export const deleteRecord = (filter: string, filterValues: any[]) => {",
      "  const queryString = `DELETE FROM ${1:tableName} \\${filter}`;",
      "  return db.execute(queryString, [...filterValues]);",
      "};"
    ],
    "description": "Mysql Model"
  },
  "Mysql Error FK Referencing wrong id": {
    "prefix": "mysql-er-fk-wrongid",
    "body": [
      "/*--- Wrong Foreign key reference ---*/",
      "if (error.errno === 1216)",
      "  return res.status(409).json({error: \"${1:message}\"});"
    ],
    "description": "Mysql Error FK Referencing wrong id"
  },
  "Mysql Error FK missing": {
    "prefix": "mysql-er-fk-missing",
    "body": [
      "/*--- Missing Foreign key ---*/",
      "if (error.errno === 1452)",
      "  return res.status(409).json({error: \"${1:message}\"});"
    ],
    "description": "Mysql Error FK missing"
  },
  "Mysql Error": {
    "prefix": "mysql-er",
    "body": [
      "/*--- ${1:Heading} ---*/",
      "if (error.errno === ${2:errorNumber})",
      "  return res.status(${3:statusCode}).json({ error: \"${4:message}\" });"
    ],
    "description": "Mysql Error"
  },
  "Mysql Error Null": {
    "prefix": "mysql-er-null",
    "body": [
      "/*--- Null Error ---*/",
      "if (error.errno === 1048) {",
      "  const mes = error.sqlMessage.split(\" \")[1];",
      "  return res",
      "    .status(400)",
      "    .json({ error: \"${1:message}\" });",
      "}"
    ],
    "description": "Mysql Error Null"
  },
  "Mysql Error Duplicate": {
    "prefix": "mysql-er-dupl",
    "body": [
      "/*--- Duplicate Error ---*/",
      "if (error.errno === 1062)",
      "  return res.status(409).json({ error: \"${1:message}\" });"
    ],
    "description": "Mysql Error Duplicate"
  },
  "Sequelize Config": {
    "prefix": "squel-cf",
    "body": [
      "import { Sequelize } from \"sequelize\";",
      "",
      "// npm i sequelize && npm i -D @types/sequelize",
      "",
      "const db = new Sequelize(\"${1:Database}\", \"${2:User}\", \"${3:Password}\", {",
      "  dialect: \"mysql\",",
      "  host: \"localhost\",",
      "});",
      "",
      "export default db;"
    ],
    "description": "Sequelize Config"
  },
  "Squelize Model": {
    "prefix": "squel-m",
    "body": [
      "import { DataTypes, Model } from \"sequelize\";",
      "",
      "interface ${1:Attributes}",
      "",
      "export class ${2:ClassName} extends Model<${1:Attributes}> {}",
      "",
      "${2:ClassName}.init(",
      "    {",
      "",
      "    },",
      "    {",
      "        sequelize: ${3:Instance of db},",
      "        tableName: \"${4:TableName}\"",
      "    }",
      ");"
    ],
    "description": "Squelize Model"
  },
  "Express session": {
    "prefix": "exp-session",
    "body": [
      "import * as session from 'express-session';",
      "// npm install --save express-session",
      "// npm install -D @types/express-session",
      "// To assign values to req.session use temp below",
      "// if(req.session) {",
      "//    req.session.YOUR_KEY = YOUR_VALUE",
      "// }",
      "app.use(",
      "  session.default({",
      "    secret:  '${1:Secret}',",
      "    resave: false,",
      "    saveUninitialized: true",
      "  })",
      ")"
    ],
    "description": "Express session"
  },
  "Express mysql-sesssion": {
    "prefix": "exp-sess-mysql",
    "body": [
      "import MySQLSessionStore from \"express-mysql-session\";",
      "//import pool from './lib/dbase';  import your database configuration module ",
      "//npm install express-mysql-session --save",
      "//npm install -D @types/express-mysql-session",
      "const MySQLStore = MySQLSessionStore(${1:session_var});",
      "const store = new MySQLStore({",
      "  schema: {",
      "    tableName: '${2:Table_Name}',",
      "    columnNames: {",
      "      session_id: 'session_id',",
      "      expires: 'expires',",
      "      data: 'data'",
      "    }",
      "  }",
      "}, pool);"
    ],
    "description": "Express mysql-sesssion"
  },
  "Express response code": {
    "prefix": "ccode",
    "body": ["return res.sendStatus(${1:code});"],
    "description": "Express response code"
  },
  "Express response code message": {
    "prefix": "cmessage",
    "body": ["return res.status(${1:code}).json({ error: \"${2:message}\" });"],
    "description": "Express response code message"
  },
  "Express middleware": {
    "prefix": "exp-midware",
    "body": [
      "import {Request, Response, NextFunction} from 'express';",
      "",
      "export default (req:Request, res:Response, next: NextFunction) => {",
      "    ${1:Code}",
      "    next();",
      "}",
      " "
    ],
    "description": "Express middleware"
  },
  "Utils-multer": {
    "prefix": "utils-multer",
    "body": [
      "import multer from 'multer';",
      "",
      "const fileStorage = multer.diskStorage({",
      "    destination: (req, file, cb) => {",
      "        cb(null, './images')",
      "    },",
      "    filename: (req, file, cb) => {",
      "        cb(null, `${new Date().toISOString()}-${file.originalname}`);",
      "    }",
      "});",
      "",
      "const fileFilter = (req: any, file: any, cb: any) => {",
      "    const maxSize = 4; // Mb",
      "    const fileSize = Math.round(req.header('content-length') / (1024 * 1024));",
      "",
      "    if (file.mimetype === 'image/png' ||",
      "        file.mimetype === 'image/jpeg' ||",
      "        file.mimetype === 'image/jpg'",
      "    ) {",
      "        if (fileSize > maxSize) cb(new Error('Size Error'), false);",
      "        else cb(null, true);",
      "    }",
      "    else cb(new Error('Mime Error'), false);",
      "}",
      "",
      "export const imageUploader = multer({",
      "    storage: fileStorage,",
      "    fileFilter: fileFilter",
      "})",
      ""
    ],
    "description": "Utils-multer"
  },
  "Express Multer": {
    "prefix": "exp-multer",
    "body": [
      "import multer from 'multer';",
      "// 1) Create external module with exp-multer-util",
      "// 2) import multerImage from './lib/filename';",
      "",
      "// .single('fieldname') | for a single file",
      "// .array('fieldname') | multiple input file tags with same fieldname",
      "// .fields([{name: 'fieldname1', maxCount: 1}, ",
      "//       {name: 'fieldname2', maxCount: 8}]) | for multiple fields on diff pages/views",
      "",
      "let upload = multerImage.single('${1:fieldName}');",
      "",
      "(req: Request, res: Response, next: NextFunction) => {",
      "    upload(req, res, function (err: any) {",
      "        if (err instanceof multer.MulterError) {",
      "            // A Multer error occurred when uploading.",
      "            console.log(err.message);",
      "        } else if (err) {",
      "            // An error occurred from multer utils.",
      "            console.log('Some yawa happen');",
      "            console.log(err.message)",
      "        }",
      "    })",
      "}"
    ],
    "description": "Express Multer"
  },
  "Express Download": {
    "prefix": "exp-download",
    "body": [
      "import fs from 'fs';",
      "",
      "let filename = 'req.params.name + '.pdf';",
      "const file = fs.createReadStream(${1:path});",
      "res.setHeader('Content-Type','application/pdf');",
      "res.setHeader(",
      "    'Content-Disposition',",
      "    '${2|inline,attachment|}; filename=\"'+filename+'\"'",
      ");",
      "file.pipe(res);"
    ],
    "description": "Express Download"
  },
  "Express Morgan": {
    "prefix": "exp-morgan",
    "body": [
      "import fs from 'fs';",
      "import path from 'path';",
      "import morgan from 'morgan';",
      "",
      "const accessLogStream = fs.createWriteStream(",
      "  path.join(__dirname, 'accessLog'),",
      "  { flags: 'a' }",
      ");",
      "",
      "app.use(morgan('combined', { stream: accessLogStream }))"
    ],
    "description": "Express Morgan"
  },
  "Express JWT": {
    "prefix": "exp-jwt",
    "body": [
      "import jsonwebtoken from 'jsonwebtoken';",
      "// npm i jsonwebtoken --save",
      "// npm i @types/jsonwebtoken -D",
      "const token = jsonwebtoken.sign({",
      "    ${1:Payload}",
      "},",
      "\"${2:secret}\",",
      "{",
      "    expiresIn: \"${3:1hr}\"",
      "});"
    ],
    "description": "Express JWT"
  },
  "Express Api Static": {
    "prefix": "exp-api-static",
    "body": [
      "if(process.env.MODE == 'PRO') {",
      "    app.use('/${1:Path}', express.static(path.join(__dirname, '${1:Path}')))",
      "}",
      "else if(process.env.MODE == 'DEV') {",
      "    app.use('/${1:Path}', express.static(path.join(__dirname, '..', '${1:Path}')))",
      "}"
    ],
    "description": "Express Api Static"
  },
  "Express Api": {
    "prefix": "exp-api",
    "body": [
      "import express, {Application, Request, Response, NextFunction} from 'express';",
      "import config from 'config';",
      "import helmet from \"helmet\";",
      "import logger from \"./utils/logger\";",
      "import swaggerUI from 'swagger-ui-express';",
      "import { swaggerSpec } from './utils/swagger';",
      "",
      "const app:Application = express();",
      "",
      "",
      "app.use((req:Request, res:Response, next: NextFunction) => {",
      "    const allowedOrigins = ['http://127.0.0.1:8020', 'http://localhost:8020', 'http://127.0.0.1:9000', 'http://localhost:9000'];",
      "    const origin = req.headers.origin;",
      "    if (allowedOrigins.includes(origin as string) || !origin) {",
      "         res.setHeader('Access-Control-Allow-Origin', origin as string);",
      "    }",
      "    else {",
      "       logger.error(`CORS blocked for \\${origin}`);",
      "    }",
      "    res.header(",
      "        'Access-Control-Allow-Headers',",
      "        'Accept, Origin, Authorization, Content-Type, X-Requested-With'",
      "    );",
      "    if (req.method === 'OPTIONS') {",
      "        res.header('Access-Control-Allow-Methods','PUT, GET, POST, DELETE, PATCH');",
      "        return res.status(200).json({})",
      "    }",
      "    res.header('Access-Control-Allow-Credentials', \"true\");",
      "    next();",
      "});",
      "",
      "app.use(helmet());",
      "app.use(express.json({limit: '10mb'}));",
      "",
      "////////////////////////////////////",
      "/// Routes",
      "app.use(",
      "  `${config.get(\"baseEndPoint\")}/docs`,",
      "  swaggerUI.serve,",
      "  swaggerUI.setup(swaggerSpec)",
      ");",
      "",
      "app.get(",
      "  `${config.get(\"baseEndPoint\")}/docs-json`,",
      "  (req: Request, res: Response) => {",
      "    res.setHeader(\"Content-Type\", \"application/json\");",
      "    res.send(swaggerSpec);",
      "  }",
      ");",
      "",
      "app.get(",
      "  `${config.get(\"baseEndPoint\")}/`,",
      "  (req: Request, res: Response) => {",
      "    res.sendStatus(200);",
      "  }",
      ");",
      "",
      "app.use((req:Request, res:Response) => {",
      "    res.sendStatus(404)",
      "})",
      "",
      "app.use((error:Error, req:Request, res:Response) => {",
      "    res.status(500).json({ error: error.message })",
      "})",
      "",
      "export default app;"
    ],
    "description": "Express Api"
  },
  "Express API v2": {
    "prefix": "exp-api-v2",
    "body": [
      "import express, { Application, Request, Response } from \"express\";",
      "import helmet from \"helmet\";",
      "import cors from \"cors\";",
      "import swaggerUI from \"swagger-ui-express\";",
      "import swaggerSpec from \"./swagger.json\";",
      "import { corsOptions } from \"./utils/cors.utils\";",
      "",
      "const app: Application = express();",
      "",
      "app.use(cors(corsOptions));",
      "app.use(helmet());",
      "app.use(express.json({ limit: \"10mb\" }));",
      "",
      "",
      "////////////////////////////////////",
      "/// Endpoints",
      "app.use(",
      "  `/docs`,",
      "  swaggerUI.serve,",
      "  swaggerUI.setup(swaggerSpec)",
      ");",
      "",
      "app.get(",
      "  `/docs-json`,",
      "  (req: Request, res: Response) => {",
      "    res.setHeader(\"Content-Type\", \"application/json\");",
      "    res.send(swaggerSpec);",
      "  }",
      ");",
      "",
      "app.get(",
      "  `/`,",
      "  (req: Request, res: Response) => {",
      "    res.sendStatus(200);",
      "  }",
      ");",
      "",
      "app.use((req: Request, res: Response) => {",
      "  res.sendStatus(404);",
      "});",
      "",
      "app.use((error: Error, req: Request, res: Response) => {",
      "  res.status(500).json({ error: error.message });",
      "});",
      "",
      "export default app;",
      ""
    ],
    "description": "Express API v2"
  },
  "Cors Options ": {
    "prefix": "utils-cors",
    "body": [
      "import { CorsOptions } from \"cors\";",
      "import logger from \"./logger.utils\";",
      "",
      "const allowedOrigins:string[] = [];",
      "",
      "export const corsOptions:CorsOptions = {",
      "  origin: (origin, callback) => {",
      "     if (allowedOrigins.length < 1) {",
      "       callback(null, true);",
      "     } else if (allowedOrigins.indexOf(origin as string) !== -1 || !origin) {",
      "       callback(null, true);",
      "     } else {",
      "       logger.error(`CORS blocked for \\${origin}`);",
      "       callback(null, false);",
      "     }",
      "  },",
      "  credentials: true,",
      "  optionsSuccessStatus: 200,",
      "};"
    ],
    "description": "Cors Options "
  },
  "Axios Instance": {
    "prefix": "ax-instance",
    "body": [
      "import axios from \"axios\";",
      "",
      "const BaseURL = import.meta.env.VITE_BASEURL;",
      "",
      "export const isAxiosError = (error: any) => {",
      "  if (axios.isAxiosError(error)) return error;",
      "  else return null;",
      "};",
      "",
      "export const axiosDefault = axios.create({",
      "  baseURL: BaseURL,",
      "  withCredentials: true,",
      "});",
      "",
      "export const axiosPrivate = axios.create({",
      "  baseURL: BaseURL,",
      "  withCredentials: true,",
      "});",
      ""
    ],
    "description": "Axios Instance"
  },
  "Swagger ": {
    "prefix": "utils-swag",
    "body": [
      "import swaggerJsDoc from \"swagger-jsdoc\";",
      "import { version } from \"../../package.json\";",
      "",
      "const options: swaggerJsDoc.Options = {",
      "  definition: {",
      "    openapi: \"3.0.0\",",
      "    info: {",
      "      title: \"${1:title}\",",
      "      version,",
      "    },",
      "    components: {",
      "      securitySchemas: {",
      "        bearerAuth: {",
      "          type: \"http\",",
      "          scheme: \"bearer\",",
      "          bearerFormat: \"JWT\",",
      "        },",
      "      },",
      "    },",
      "    security: [",
      "      {",
      "        bearerAuth: [],",
      "      },",
      "    ],",
      "  },",
      "  apis: [\"./src/routes/*.ts\", \"./src/schema/*.ts\"],",
      "};",
      "",
      "export const swaggerSpec = swaggerJsDoc(options);"
    ],
    "description": "Swagger "
  },
  "Prisma Client": {
    "prefix": "pris-cl",
    "body": [
      "import { PrismaClient } from \"@prisma/client\";",
      "export const prisma = new PrismaClient();"
    ],
    "description": "Prisma Client"
  },
  "Prisma Migrate": {
    "prefix": "pris-mi",
    "body": ["npx prisma migrate dev --name ${1:name}"],
    "description": "Prisma Migrate"
  },
  "Pothos Builder": {
    "prefix": "po-builder",
    "body": [
      "builder.prismaObject(\"\", {",
      "  fields: (t) => ({",
      "    ",
      "  }),",
      "});"
    ],
    "description": "Pothos Builder"
  },
  "Prisma Client W/ Log": {
    "prefix": "pris-cl-log",
    "body": [
      "import { PrismaClient } from \"@prisma/client\";",
      "export const prisma = new PrismaClient({",
      "  log: [",
      "    {",
      "      level: \"query\",",
      "      emit: \"event\",",
      "    },",
      "    {",
      "      level: \"error\",",
      "      emit: \"event\",",
      "    },",
      "  ],",
      "});",
      "",
      "prisma.$on(\"query\", (e) => {",
      "  console.log(\"Params \", e.params);",
      "  console.log(\"Query \", e.query);",
      "});",
      "prisma.$on(\"error\", (e) => {",
      "  console.log(\"Error \", e.message);",
      "});"
    ],
    "description": "Prisma Client W/ Log"
  },
  "Prisma Pothos Generator": {
    "prefix": "pris-pot-gen",
    "body": ["generator pothos {", "  provider = \"prisma-pothos-types\"", "}"],
    "description": "Prisma Pothos Generator"
  },
  "Utils Pothos Builder": {
    "prefix": "utils-builder",
    "body": [
      "import SchemaBuilder from \"@pothos/core\";",
      "import { DateResolver } from \"graphql-scalars\";",
      "import PrismaPlugin from \"@pothos/plugin-prisma\";",
      "import type PrismaTypes from \"@pothos/plugin-prisma/generated\";",
      "import { prisma } from \"./db.utils\";",
      "",
      "export const builder = new SchemaBuilder<{",
      "  Scalars: { Date: { Input: Date; Output: Date } };",
      "  PrismaTypes: PrismaTypes;",
      "}>({",
      "  plugins: [PrismaPlugin],",
      "  prisma: {",
      "    client: prisma,",
      "  },",
      "});",
      "",
      "builder.queryType({});",
      "builder.addScalarType(\"Date\", DateResolver, {});",
      ""
    ],
    "description": "Utils Pothos Builder"
  },
  "Utils Graph Schema": {
    "prefix": "utils-schema",
    "body": [
      "import { builder } from \"./builder.utils\";",
      "",
      "import \"../models/Post\";",
      "import \"../models/User\";",
      "",
      "export const schema = builder.toSchema();"
    ],
    "description": "Utils Graph Schema"
  },
  "Utils Mailer": {
    "prefix": "utils-mailer",
    "body": [
      "import nodemailer from \"nodemailer\";",
      "",
      "export const transporter = nodemailer.createTransport({",
      "  host: \"${1:host}\",",
      "  auth: {",
      "    user: process.env.USER_MAIL,",
      "    pass: process.env.PASS_MAIL,",
      "  },",
      "  port: ${2|587,465|},",
      "  secure: ${3|false,true|},",
      "});",
      ""
    ],
    "description": "Utils Mailer"
  },
  "Utils Mailer Import": {
    "prefix": "utils-mailer-import",
    "body": [
      "import {transporter} from './utils/mail.utils'",
      "",
      "const messageInfo = {",
      "  from: '\"${1:Company}\" <${2:email}>',",
      "  to: \"${2:To}\",",
      "  subject: \"${3:Subject}\",",
      "  text: \"${4:message}\",",
      "};",
      "",
      "transporter.sendMail(messageInfo, (error, info) => {",
      "  if (error) {",
      "    return console.log(error);",
      "  }",
      "  console.log(\"Message sent: %s\", info.messageId);",
      "});"
    ],
    "description": "Utils Mailer Import"
  },
  "Prisma Error block": {
    "prefix": "pris-err",
    "body": [
      "if (error instanceof Prisma.PrismaClientKnownRequestError) {",
      "    console.log(error.message);",
      "    if(error.code === ${1:unique_P2002}){",
      "        ${2}",
      "    }",
      "}"
    ],
    "description": "Prisma Error block"
  }
}
