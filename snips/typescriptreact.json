{
  "Next Page": {
    "prefix": "nxt-page",
    "body": [
      "import { NextPage } from \"next\";",
      "",
      "const ${1:name}: NextPage = () => {",
      "  return <h1>${1:name}</h1>;",
      "};",
      "",
      "export default ${1:name};"
    ],
    "description": "Next Page"
  },
  "Next static": {
    "prefix": "nxt-static",
    "body": [
      "import { NextPage } from \"next\";",
      "import Head from \"next/head\";",
      "",
      "const ${1:pageName}: NextPage = () => {",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${3:title}</title>",
      "        <meta name=\"description\" content=\"${4:description}\" />",
      "        <link rel=\"canonical\" href=\"/${5:page}\" />",
      "         ${6:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${1:pageName};"
    ],
    "description": "Next static"
  },
  "Next App Apollo": {
    "prefix": "nxt-app-apollo",
    "body": [
      "import { ApolloProvider } from '@apollo/client'",
      "import { useApollo } from '../lib/apollo-client'",
      "",
      "const apolloClient = useApollo(pageProps)",
      "",
      "<ApolloProvider client={apolloClient}></ApolloProvider>",
      ""
    ],
    "description": "Next App Apollo"
  },
  "Next SSG": {
    "prefix": "nxt-ssg",
    "body": [
      "import { GetStaticProps, NextPage } from \"next\";",
      "import axios from \"axios\";",
      "import Head from \"next/head\";",
      "",
      "type ${1:pageName}Type = {",
      "  ${2:}",
      "}",
      "",
      "type ${1:pageName}Props = {",
      "  ${3:pageName}: ${1:pageName}Type[]",
      "};",
      "",
      "const ${1:pageName}: NextPage<${1:pageName}Props> = ({${3:pageName}}) => {",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${4:title}</title>",
      "        <meta name=\"description\" content=\"${5:description}\" />",
      "        <link rel=\"canonical\" href=\"/${6:page}\" />",
      "        ${7:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${1:pageName};",
      "",
      "",
      "////////////////////////////////////",
      "/// GetStaticProps ",
      "",
      "export const getStaticProps: GetStaticProps = async () => {",
      "  const result = await axios.get<${1:pageName}Props>(\"${8:url}\");",
      "",
      "  const ${3:pageName}:${1:pageName}Type[] = result.data.${3:pageName}.map((item) => {",
      "    return {",
      "      ${9:}",
      "    };",
      "  });",
      "  ",
      "  return {",
      "    props: {",
      "      ${3:pageName}",
      "    }",
      "  };",
      "};"
    ],
    "description": "Next SSG"
  },
  "Next SSG Graph": {
    "prefix": "nxt-ssg-gql",
    "body": [
      "import { GetStaticProps, NextPage } from \"next\";",
      "import { initializeApollo } from '../lib/apollo-client';",
      "import { gql } from '@apollo/client';",
      "import Head from \"next/head\";",
      "",
      "type ${1:pageName}Type = {",
      "  ${2:}",
      "}",
      "",
      "type ${1:pageName}Props = {",
      "  ${3:pageName}: ${1:pageName}Type[]",
      "};",
      "",
      "const ${1:pageName}: NextPage<${1:pageName}Props> = ({${3:pageName}}) => {",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${4:title}</title>",
      "        <meta name=\"description\" content=\"${5:description}\" />",
      "        <link rel=\"canonical\" href=\"/${6:page}\" />",
      "        ${7:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${1:pageName};",
      "",
      "",
      "////////////////////////////////////",
      "/// GetStaticProps ",
      "",
      "export const getStaticProps: GetStaticProps = async () => {",
      "  const client = initializeApollo();",
      "",
      "  const result = await client.query<{ ${8:queryName}: ${1:pageName}Type[] }>({",
      "    query:gql`",
      "      ${9:}",
      "  `});",
      "  ",
      "const ${3:pageName} = result.data.${8:queryName}.map((item) => {",
      "   return {",
      "      ${10:}",
      "   };",
      "});",
      "",
      "  return {",
      "    props: {",
      "      ${3:pageName}",
      "    }",
      "  };",
      "};"
    ],
    "description": "Next SSG gql"
  },
  "Next SSG Dynamic": {
    "prefix": "nxt-ssg-dyn",
    "body": [
      "import { GetStaticPaths, GetStaticProps, NextPage } from \"next\";",
      "import { ParsedUrlQuery } from \"querystring\";",
      "import axios from \"axios\";",
      "import Head from \"next/head\";",
      "import { useRouter } from \"next/router\";",
      "",
      "type ${1:pageName}PathType = {",
      "  ${2:id:string;}",
      "}",
      "",
      "type ${1:pageName}Type = {",
      "  ${3:}",
      "}",
      "",
      "type ${1:pageName}Props = {",
      "  ${4:pageName}: ${1:pageName}Type",
      "};",
      "",
      "const ${1:pageName}Detail: NextPage<${1:pageName}Props> = ({${4:pageName}}) => {",
      "  const router = useRouter();",
      "",
      "  if (router.isFallback) {",
      "    return <h1>Loading......</h1>;",
      "  }",
      "",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${5:title}</title>",
      "        <meta name=\"description\" content=\"${6:description}\" />",
      "        <link rel=\"canonical\" href=\"/${7:page}\" />",
      "        ${8:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${1:pageName}Detail;",
      "",
      "////////////////////////////////////",
      "/// Interfaces",
      "",
      "export interface IParams extends ParsedUrlQuery {",
      "  ${9:paramsID}: string;",
      "}",
      "",
      "////////////////////////////////////",
      "/// GetStaticPaths & GetStaticProps",
      "",
      "export const getStaticPaths: GetStaticPaths = async () => {",
      "  const result = await axios.get<{data:${1:pageName}PathType[]}>(`${10:url}`);",
      "",
      "  const paths = result.data.data.map((item) => {",
      "    return {",
      "      params: { ${9:paramsID}: ${11:item} },",
      "    };",
      "  });",
      "",
      "  return {",
      "    paths,",
      "    fallback: true,",
      "  };",
      "};",
      "",
      "export const getStaticProps: GetStaticProps = async (ctx) => {",
      "  const { ${9:paramsID} } = ctx.params as IParams;",
      "  const result = await axios.get<${1:pageName}Type>(`${10:url}/\\${${9:paramsID}}`);",
      "",
      "  const ${4:pageName}:${1:pageName}Type = {",
      "    ${12:}",
      "  }",
      "  ",
      "  return {",
      "    props: {",
      "      ${4:pageName}",
      "    }",
      "  };",
      "};"
    ],
    "description": "Next SSG Dynamic"
  },
  "Next SSG dynamic Graph": {
    "prefix": "nxt-ssg-dyn-gql",
    "body": [
      "import { GetStaticPaths, GetStaticProps, NextPage } from \"next\";",
      "import { ParsedUrlQuery } from \"querystring\";",
      "import Head from \"next/head\";",
      "import { useRouter } from \"next/router\";",
      "import { initializeApollo } from \"../lib/apollo-client\";",
      "import { gql } from \"@apollo/client\";",
      "",
      "type ReturnPathIDType = {",
      "  ${1:id: string};",
      "};",
      "",
      "type ${2:entity}Type = {",
      "  ${3}",
      "};",
      "",
      "type ${2:entity}Props = {",
      "  ${4:propName}: ${2:entity}Type;",
      "};",
      "",
      "const ${2:entity}Detail: NextPage<${2:entity}Props> = ({ ${4:propName} }) => {",
      "  const router = useRouter();",
      "",
      "  if (router.isFallback) {",
      "    return <h1>Loading......</h1>;",
      "  }",
      "",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${5:title}</title>",
      "        <meta name=\"description\" content=\"${6:description}\" />",
      "        <link rel=\"canonical\" href=\"/${7:page}\" />",
      "        ${8:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${2:entity}Detail;",
      "",
      "////////////////////////////////////",
      "/// Interfaces",
      "",
      "export interface IParams extends ParsedUrlQuery {",
      "  ${9:paramsID}: string;",
      "}",
      "",
      "const client = initializeApollo();",
      "",
      "////////////////////////////////////",
      "/// GetStaticPaths & GetStaticProps",
      "",
      "export const getStaticPaths: GetStaticPaths = async () => {",
      "  const result = await client.query<{ ${10:queryName}: ReturnPathIDType[] }>({",
      "    query: gql`",
      "      query {",
      "        ${10:queryName} {",
      "          ${11}",
      "        }",
      "      }",
      "    `,",
      "  });",
      "",
      "  const paths = result.data.getUsers.map((item) => {",
      "    return {",
      "      params: { ${9:paramsID}: item.id },",
      "    };",
      "  });",
      "",
      "  return {",
      "    paths,",
      "    fallback: true,",
      "  };",
      "};",
      "",
      "export const getStaticProps: GetStaticProps = async (ctx) => {",
      "  const { ${9:paramsID} } = ctx.params as IParams;",
      "  const result = await client.query<{ ${12:queryName}: ${2:entity}Type }>({",
      "    query: gql`",
      "      query ($${9:paramsID}: ID!) {",
      "        ${12:queryName}(id: $${9:paramsID}) {",
      "          ${13}",
      "        }",
      "      }",
      "    `,",
      "    variables: { ${9:paramsID} },",
      "  });",
      "",
      "  const ${4:propName}: ${2:entity}Type = {",
      "    ${14}",
      "  };",
      "",
      "  return {",
      "    props: {",
      "      ${4:propName},",
      "    },",
      "  };",
      "};",
      ""
    ],
    "description": "Next SSG dynamic Graph"
  },
  "Next Server side": {
    "prefix": "nxt-svr",
    "body": [
      "import { GetServerSideProps, NextPage } from \"next\";",
      "import axios from \"axios\";",
      "import Head from \"next/head\";",
      "",
      "type ${1:pageName}Type = {",
      "  ${3:}",
      "}",
      "",
      "type ${1:pageName}Props = {",
      "  ${4:pageName}: ${1:pageName}Type",
      "};",
      "",
      "const ${1:pageName}Detail: NextPage<${1:pageName}Props> = ({${4:pageName}}) => {",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${5:title}</title>",
      "        <meta name=\"description\" content=\"${6:description}\" />",
      "        <link rel=\"canonical\" href=\"/${7:page}\" />",
      "        ${8:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${1:pageName}Detail;",
      "",
      "////////////////////////////////////",
      "/// GetServerProps",
      "",
      "export const getServerSideProps: GetServerSideProps = async () => {",
      "  const result = await axios.get<${1:pageName}Type>(`${10:url}`);",
      "",
      "  const ${4:pageName}:${1:pageName}Type = {",
      "    ${12:}",
      "  }",
      "  ",
      "  return {",
      "    props: {",
      "      ${4:pageName}",
      "    }",
      "  };",
      "};"
    ],
    "description": "Next Server side"
  },
  "Next Server side Dynamic": {
    "prefix": "nxt-svr-dyn",
    "body": [
      "import { GetServerSideProps, NextPage } from \"next\";",
      "import { ParsedUrlQuery } from \"querystring\";",
      "import axios from \"axios\";",
      "import Head from \"next/head\";",
      "",
      "type ${1:pageName}Type = {",
      "  ${3:}",
      "}",
      "",
      "type ${1:pageName}Props = {",
      "  ${4:pageName}: ${1:pageName}Type",
      "};",
      "",
      "const ${1:pageName}Detail: NextPage<${1:pageName}Props> = ({${4:pageName}}) => {",
      "  return (",
      "    <>",
      "      <Head>",
      "        <title>${5:title}</title>",
      "        <meta name=\"description\" content=\"${6:description}\" />",
      "        <link rel=\"canonical\" href=\"/${7:page}\" />",
      "        ${8:<meta name=\"robots\" content=\"noindex\" />}",
      "      </Head>",
      "    </>",
      "  );",
      "};",
      "",
      "export default ${1:pageName}Detail;",
      "",
      "////////////////////////////////////",
      "/// Interfaces",
      "",
      "export interface IParams extends ParsedUrlQuery {",
      "  ${9:paramsID}: string;",
      "}",
      "",
      "////////////////////////////////////",
      "/// GetServerProps",
      "",
      "export const getServerSideProps: GetServerSideProps = async (ctx) => {",
      "  const { ${9:paramsID} } = ctx.params as IParams;",
      "  const result = await axios.get<${1:pageName}Type>(`${10:url}/\\${${9:paramsID}}`);",
      "",
      "  const ${4:pageName}:${1:pageName}Type = {",
      "    ${12:}",
      "  }",
      "  ",
      "  return {",
      "    props: {",
      "      ${4:pageName}",
      "    }",
      "  };",
      "};"
    ],
    "description": "Next Server side Dynamic"
  },
  "Next NavBar": {
    "prefix": "nxt-navbar",
    "body": [
      "import Link from \"next/link\";",
      "import { useEffect, useState } from \"react\";",
      "",
      "const ${1:NavBar} = () => {",
      "  const [current, setCurrent] = useState(\"\");",
      "",
      "  useEffect(() => {",
      "    typeof window !== undefined && setCurrent(window.location.pathname);",
      "  }, []);",
      "",
      "  return (",
      "    <nav>",
      "      ${2:}",
      "    </nav>",
      "  );",
      "};",
      "",
      "export default ${1:NavBar};"
    ],
    "description": "Next NavBar"
  },
  "Next Private Comp + Roles": {
    "prefix": "nxt-priv-comp",
    "body": [
      "import useAppContext from \"@/hooks/useAppContext\";",
      "import useAuth from \"@/hooks/useAuth\";",
      "import { isExpired } from \"@/lib/auth\";",
      "import { useRouter } from \"next/router\";",
      "import { useEffect, useState } from \"react\";",
      "",
      "type PrivateCompType = {",
      "  children: React.ReactNode;",
      "  allowedRoles: number[];",
      "};",
      "",
      "function PrivateComp({ children, allowedRoles }: PrivateCompType) {",
      "  const [show, setShow] = useState(false);",
      "  const { setlogOutState } = useAuth();",
      "  const {",
      "    appState: {",
      "      auth: { id, maxAge, roles },",
      "    },",
      "    dispatch,",
      "  } = useAppContext();",
      "  const router = useRouter();",
      "",
      "  useEffect(() => {",
      "    if (!isExpired(maxAge) && id) {",
      "      const isAuth = roles",
      "        .map((ele) => allowedRoles.includes(ele))",
      "        .find((ele) => ele === true);",
      "      if (!isAuth) {",
      "        router.push(\"/unauth\");",
      "      } else setShow(true);",
      "    } else {",
      "      if (id) setlogOutState();",
      "      router.push(\"/login\");",
      "    }",
      "",
      "    window.addEventListener(\"focus\", setlogOutState);",
      "",
      "    return () => {",
      "      window.removeEventListener(\"focus\", setlogOutState);",
      "    };",
      "  }, [allowedRoles, dispatch, id, maxAge, roles, router, setlogOutState]);",
      "",
      "  return <>{show && children}</>;",
      "}",
      "",
      "export default PrivateComp;",
      ""
    ],
    "description": "Next Private Comp + Roles"
  },
  "Next Authenticate Comp": {
    "prefix": "nxt-auth-comp",
    "body": [
      "import useAppContext from \"@/hooks/useAppContext\";",
      "import { useRouter } from \"next/router\";",
      "import { useEffect, useState } from \"react\";",
      "",
      "type AuthCompType = {",
      "  children: React.ReactNode;",
      "};",
      "",
      "function AuthComp({ children }: AuthCompType) {",
      "  const [show, setShow] = useState(false);",
      "  const {",
      "    appState: {",
      "      auth: { id },",
      "    },",
      "  } = useAppContext();",
      "  const router = useRouter();",
      "",
      "  useEffect(() => {",
      "    if (id) {",
      "      router.back();",
      "    } else setShow(true);",
      "  }, [id, router]);",
      "",
      "  return <>{show && children}</>;",
      "}",
      "",
      "export default AuthComp;"
    ],
    "description": "Next Authenticate Comp"
  },
  "Next useAuth": {
    "prefix": "nxt-use-auth",
    "body": [
      "import { authType } from \"@/context/AppReducer\";",
      "import useAppContext from \"./useAppContext\";",
      "",
      "function useAuth(): {",
      "  setlogInState: (state: authType) => void;",
      "  setlogOutState: () => void;",
      "} {",
      "  const { dispatch } = useAppContext();",
      "",
      "  ////////////////////////////////////",
      "  /// Log In State",
      "  const setlogInState = (state: authType) => {",
      "    dispatch({ type: \"SET_ID\", payload: state.id });",
      "    dispatch({ type: \"SET_MAX_AGE\", payload: state.maxAge });",
      "    dispatch({ type: \"SET_ROLES\", payload: state.roles });",
      "  };",
      "",
      "  ////////////////////////////////////",
      "  /// Lot Out State",
      "  const setlogOutState = () => {",
      "    dispatch({ type: \"SET_ID\", payload: \"\" });",
      "    dispatch({ type: \"SET_MAX_AGE\", payload: \"\" });",
      "    dispatch({ type: \"SET_ROLES\", payload: [] });",
      "  };",
      "",
      "  return { setlogInState, setlogOutState };",
      "}",
      "",
      "export default useAuth;"
    ],
    "description": "Next useAuth"
  },
  "Next useAppContext": {
    "prefix": "nxt-use-appctx",
    "body": [
      "import { AppContext } from \"@/context/AppContextProvider\";",
      "import { ActionType, StateType } from \"@/context/AppReducer\";",
      "import { Dispatch, useContext } from \"react\";",
      "",
      "function useAppContext(): {",
      "  appState: StateType;",
      "  dispatch: Dispatch<ActionType>;",
      "} {",
      "  const appCxt = useContext(AppContext);",
      "  return {",
      "    appState: appCxt?.appState as StateType,",
      "    dispatch: appCxt?.dispatch as Dispatch<ActionType>,",
      "  };",
      "}",
      "",
      "export default useAppContext;"
    ],
    "description": "Next useAppContext"
  },
  "Nextjs MUI cache": {
    "prefix": "nxt-mui-cache",
    "body": [
      "import createCache from '@emotion/cache';",
      "",
      "// prepend: true moves MUI styles to the top of the <head> so they're loaded first.",
      "// It allows developers to easily override MUI styles with other styling solutions, like CSS modules.",
      "export default function createEmotionCache() {",
      "  return createCache({ key: 'css', prepend: true });",
      "}"
    ],
    "description": "Nextjs MUI cache"
  },
  "Nextjs MUI _App": {
    "prefix": "nxt-mui-app",
    "body": [
      "import * as React from 'react';",
      "import PropTypes from 'prop-types';",
      "import Head from 'next/head';",
      "import { ThemeProvider } from '@mui/material/styles';",
      "import CssBaseline from '@mui/material/CssBaseline';",
      "import { CacheProvider } from '@emotion/react';",
      "import theme from '../src/theme';",
      "import createEmotionCache from '../src/createEmotionCache';",
      "",
      "// Client-side cache, shared for the whole session of the user in the browser.",
      "const clientSideEmotionCache = createEmotionCache();",
      "",
      "export default function MyApp(props) {",
      "  const { Component, emotionCache = clientSideEmotionCache, pageProps } = props;",
      "",
      "  return (",
      "    <CacheProvider value={emotionCache}>",
      "      <Head>",
      "        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\" />",
      "      </Head>",
      "      <ThemeProvider theme={theme}>",
      "        {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}",
      "        <CssBaseline />",
      "        <Component {...pageProps} />",
      "      </ThemeProvider>",
      "    </CacheProvider>",
      "  );",
      "}",
      "",
      "MyApp.propTypes = {",
      "  Component: PropTypes.elementType.isRequired,",
      "  emotionCache: PropTypes.object,",
      "  pageProps: PropTypes.object.isRequired,",
      "};"
    ],
    "description": "Nextjs MUI _App"
  },
  "React functional comp": {
    "prefix": "rc-func",
    "body": [
      "function ${1:Name}() {",
      "    return (",
      "        ${2}",
      "    )",
      "}",
      "",
      "export default ${1:Name};"
    ],
    "description": "React functional comp"
  },
  "React Protected Route": {
    "prefix": "rc-protected",
    "body": [
      "import { Navigate, Outlet } from \"react-router-dom\";",
      "",
      "function ProtectedRoute() {",
      "",
      "  return true ? <Outlet /> : <Navigate to=\"/login\" />;",
      "}",
      "",
      "export default ProtectedRoute;"
    ],
    "description": "React Protected Route"
  },
  "React Function context": {
    "prefix": "rc-func-context",
    "body": [
      "import { createContext } from \"react\";",
      "",
      "type ${1:Name}ContextProviderType = {",
      "  children: React.ReactNode;",
      "};",
      "",
      "",
      "",
      "export type ${1:Name}ContextType = {}",
      "",
      "export const ${1:Name}Context = createContext<${1:Name}ContextType | null>(null);",
      "",
      "function ${1:Name}ContextProvider({ children }: ${1:Name}ContextProviderType) {",
      "  return (",
      "    <${1:Name}Context.Provider value={}>",
      "      {children}",
      "    </${1:Name}Context.Provider>",
      "  );",
      "}",
      "",
      "export default ${1:Name}ContextProvider;",
      ""
    ],
    "description": "React Function context"
  },
  "React Axioa Context Interceptors": {
    "prefix": "rc-ctx-interceptor",
    "body": [
      "useEffect(() => {",
      "    const requestInter = axiosPriv.interceptors.request.use(",
      "      (config: AxiosRequestConfig) => {",
      "        if (!config?.headers?.Authorization) {",
      "          config.headers = {",
      "            Authorization: `Bearer ${appState.auth.token}`,",
      "          };",
      "        }",
      "        return config;",
      "      },",
      "      (error: AxiosError) => Promise.reject(error)",
      "    );",
      "",
      "    const responseInter = axiosPriv.interceptors.response.use(",
      "      (response) => response,",
      "      async (error: AxiosError) => {",
      "        const res = error.response;",
      "        const privRequest = error.config as IAxConfig;",
      "        if (res?.status === 401 && !privRequest.sent) {",
      "          privRequest.sent = true;",
      "",
      "          const resp = await axiosPriv.get(",
      "            `/auth/refresh?user=${appState.auth.id}`",
      "          );",
      "",
      "          const token = resp.data.token;",
      "          dispatch({ type: \"SET_TOKEN\", payload: token });",
      "",
      "          privRequest.headers = {",
      "            Authorization: `Bearer ${token}`,",
      "          };",
      "",
      "          return axiosPriv(privRequest);",
      "        }",
      "",
      "        if (res?.status === 403) {",
      "",
      "        }",
      "",
      "        return Promise.reject(error);",
      "      }",
      "    );",
      "",
      "    return () => {",
      "      axiosPriv.interceptors.request.eject(requestInter);",
      "      axiosPriv.interceptors.response.eject(responseInter);",
      "    };",
      "  }, [appState.auth.id, appState.auth.token]);"
    ],
    "description": "React Axioa Context Interceptors"
  },
  "React Func Comp with State": {
    "prefix": "rc-func-state",
    "body": [
      "import { useState } from \"react\";",
      "",
      "function ${1:Name}() {",
      "  const [${2:value}, set${3:Value}] = useState(${4:value});",
      "",
      "  return (",
      "    <>",
      "      ",
      "    </>",
      "  );",
      "}",
      "",
      "export default ${1:Name};"
    ],
    "description": "React Func Comp with State"
  },
  "MUI custom func comp for Hookform": {
    "prefix": "rc-func-muf",
    "body": [
      "import { useState } from \"react\";",
      "",
      "type ItemType = { key: string; value: any };",
      "",
      "function ${1:Name}(props:any) {",
      "  const [${2:value}, set${3:Value}] = useState(${4:value});",
      "",
      "  const handleChange = () => {",
      "    // props.onChange && props.onChange(e.target.value);",
      "  };",
      "",
      "  return (",
      "    <>",
      "      ",
      "    </>",
      "  );",
      "}",
      "",
      "export default ${1:Name};"
    ],
    "description": "MUI custom func comp for Hookform"
  },
  "React Route": {
    "prefix": "rc-route",
    "body": ["<Route path=\"${1:path}\" element={<${2:Component} />} />"],
    "description": "React Route"
  },
  "React Route open": {
    "prefix": "rc-route-o",
    "body": ["<Route path=\"${1:path}\" element={<${2:Component} />}></Route>"],
    "description": "React Route open"
  },
  "React Route No path": {
    "prefix": "rc-route-no",
    "body": ["<Route element={<${1:Component} />}></Route>"],
    "description": "React Route No path"
  },
  "React SVG": {
    "prefix": "rc-svg",
    "body": ["<svg>", "    <use xlinkHref=\"${1:path}\"></use>", "</svg>"],
    "description": "React SVG"
  },
  "React Fragment": {
    "prefix": "rcf",
    "body": ["<>", "  ${1}", "</>"],
    "description": "React Fragment"
  },
  "Material Menu": {
    "prefix": "mui-menu",
    "body": [
      "const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);",
      "const open = Boolean(anchorEl);",
      "",
      "const handleClose = () => {",
      "  setAnchorEl(null);",
      "};",
      "",
      "const handleOpen = (e: React.MouseEvent<HTMLButtonElement>) => {",
      "  setAnchorEl(e.currentTarget);",
      "};",
      "",
      "<Box>",
      "  <Button",
      "    id=\"${1:ButtonId}\"",
      "    onClick={handleOpen}",
      "    aria-controls={open ? \"${2:menuID}\" : undefined}",
      "    aria-haspopup=\"true\"",
      "    aria-expanded={open ? \"true\" : undefined}",
      "  >",
      "    Resource",
      "  </Button>",
      "  <Menu",
      "    id=\"${2:menuID}\"",
      "    anchorEl={anchorEl}",
      "    open={open}",
      "    MenuListProps={{",
      "      \"aria-labelledby\": \"${1:ButtonId}\",",
      "    }}",
      "    onClose={handleClose}",
      "  >",
      "    <MenuItem onClick={handleClose}>One</MenuItem>",
      "    <MenuItem onClick={handleClose}>Two</MenuItem>",
      "  </Menu>",
      "</Box>",
      ""
    ],
    "description": "Material Menu"
  },
  "Material Accordion": {
    "prefix": "mui-accord",
    "body": [
      "const [expanded, setExpanded] = useState<string | false>(false);",
      "",
      "const handleChange = (isExp: boolean, name: string) => {",
      "  setExpanded(isExp ? name : false);",
      "};",
      "",
      "<Stack>",
      "  <Accordion",
      "    expanded={expanded === \"${1:title}\"}",
      "    onChange={(e, isExp) => handleChange(isExp, \"${1:title}\")}",
      "    disableGutters",
      "  >",
      "    <AccordionSummary",
      "      id=\"${1:title}\"",
      "      aria-controls=\"${1:title}-content\"",
      "      expandIcon={<ExpandMore />}",
      "    >",
      "      <Typography>${1:title}</Typography>",
      "    </AccordionSummary>",
      "    <AccordionDetails>",
      "      <Typography>${2:content}</Typography>",
      "    </AccordionDetails>",
      "  </Accordion>",
      "</Stack>;"
    ],
    "description": "Material Accordion"
  },
  "Material Table": {
    "prefix": "mui-table",
    "body": [
      "const columns = [];",
      "const rows = [];",
      "const [page, setPage] = useState(0);",
      "const [rowsPerPage, setRowsPerPage] = useState(5);",
      "",
      "const handleChangePage = (e: any, newPage: number) => {",
      "  setPage(newPage);",
      "};",
      "",
      "const handleChangeRowsPerPage = (e: any) => {",
      "  setRowsPerPage(e.target.value);",
      "};",
      "",
      "<TableContainer component={Paper} sx={{ borderRadius: 2 }}>",
      "  <Table sx={{ minWidth: 650 }}>",
      "    <TableHead>",
      "      <TableRow>",
      "        {columns.map((cell, i) => (",
      "          <React.Fragment key={i}>",
      "            <CusCell>{cell}</CusCell>",
      "          </React.Fragment>",
      "        ))}",
      "      </TableRow>",
      "    </TableHead>",
      "    <TableBody>",
      "      {rows",
      "        .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)",
      "        .map((cell, i) => (",
      "          <TableRow key={i}>",
      "            <TableCell>{cell.dateJoin}</TableCell>",
      "          </TableRow>",
      "        ))}",
      "    </TableBody>",
      "  </Table>",
      "  <TablePagination",
      "    rowsPerPageOptions={[5, 10, 15]}",
      "    component=\"div\"",
      "    count={rows.length}",
      "    page={page}",
      "    rowsPerPage={rowsPerPage}",
      "    onPageChange={handleChangePage}",
      "    onRowsPerPageChange={handleChangeRowsPerPage}",
      "  />",
      "</TableContainer>"
    ],
    "description": "Material Table"
  },
  "X Data grid ": {
    "prefix": "mui-data-grid",
    "body": [
      "import { DataGrid, GridRowsProp, GridColDef } from \"@mui/x-data-grid\";",
      "",
      "const rows: GridRowsProp = [",
      "  { id: 1, col1: \"Hello\", col2: \"World\" },",
      "  { id: 2, col1: \"DataGridPro\", col2: \"is Awesome\" },",
      "  { id: 3, col1: \"MUI\", col2: \"is Amazing\" },",
      "];",
      "",
      "const columns: GridColDef[] = [",
      "  { field: \"col1\", headerName: \"Column 1\", width: 150 },",
      "  { field: \"col2\", headerName: \"Column 2\", width: 150 },",
      "];",
      "",
      "<DataGrid rows={rows} columns={columns} />;"
    ],
    "description": "X Data grid "
  },
  "MUI Style Component": {
    "prefix": "mui-style",
    "body": [
      "import { styled } from \"@mui/material\";",
      "",
      "export const ${1:Name} = styled(${2:Component})(({ theme }) => ({",
      "  ",
      "}));"
    ],
    "description": "MUI Style Component"
  },
  "Reack hook form controller": {
    "prefix": "hook-ctrlr",
    "body": [
      "<Controller",
      "  name=\"Register Name\"",
      "  control={control}",
      "  render={({ field }) => ()}/>"
    ],
    "description": "Reack hook form controller"
  },
  "R Hook form errors for MUITextfield": {
    "prefix": "hook-MuiText-errors",
    "body": [
      "{...register('${1:fieldName}')}",
      "error={!!errors.${1:fieldName}}",
      "helperText={!!errors.${1:fieldName} && errors.${1:fieldName}.message}"
    ],
    "description": "R Hook form errors for MUITextfield"
  },
  "Functional Component and RHookForm": {
    "prefix": "rc-func-hookform",
    "body": [
      "import { yupResolver } from \"@hookform/resolvers/yup\";",
      "import { useForm } from \"react-hook-form\";",
      "import * as yup from \"yup\";",
      "",
      "const ${2:schemaName} = yup.object({});",
      "",
      "export type ${2:schemaName}Type = yup.TypeOf<typeof ${2:schemaName}>;",
      "",
      "function ${1:ComponentName}() {",
      "  const {",
      "    register,",
      "    handleSubmit,",
      "    formState: { errors },",
      "  } = useForm<${2:schemaName}Type>({",
      "    defaultValues: {},",
      "    resolver: yupResolver(${2:schemaName}),",
      "    mode: \"onBlur\",",
      "  });",
      "",
      "  const onSubmit = (data: ${2:schemaName}Type) => {",
      "    console.log(data);",
      "  };",
      "",
      "  return <form onSubmit={handleSubmit(onSubmit)}></form>",
      "}",
      "",
      "export default ${1:ComponentName};",
      ""
    ],
    "description": "Functional Component and RHookForm"
  },
  "MUI date-time provider": {
    "prefix": "mui-date-time-provider",
    "body": [
      "import { LocalizationProvider } from \"@mui/lab\";",
      "import AdapterDateFns from \"@mui/lab/AdapterDateFns\";",
      "",
      "<LocalizationProvider dateAdapter={AdapterDateFns}></LocalizationProvider>"
    ],
    "description": "MUI date-time provider"
  },
  "MUI date-time": {
    "prefix": "mui-date-time",
    "body": [
      "{/* import { DatePicker } from \"@mui/lab\"; */}",
      "<DatePicker",
      "  label=\"${1:label}\"",
      "  renderInput={(params) => <TextField {...params} />}",
      "/>"
    ],
    "description": "MUI date-time"
  },
  "MUI date-range": {
    "prefix": "mui-date-range",
    "body": [
      "{/* import { DateRangePicker } from \"@mui/lab\"; */}",
      "<DateRangePicker",
      "  startText=\"${1:startText}\"",
      "  endText=\"${2:endText}\"",
      "  renderInput={(startProps, endProps) => (",
      "    <>",
      "      <TextField {...startProps} />",
      "      <Box sx={{ mx: 2 }}>to</Box>",
      "      <TextField {...endProps} />",
      "    </>",
      "  )}",
      "/>"
    ],
    "description": "MUI date-range"
  },
  "Next Setup React Query": {
    "prefix": "nxt-app-reactq",
    "body": [
      "import { useRef } from \"react\";",
      "import { QueryClient, QueryClientProvider } from \"react-query\";",
      "import { ReactQueryDevtools } from \"react-query/devtools\";",
      "",
      "  const client = useRef(new QueryClient());",
      "    <QueryClientProvider client={client.current}></QueryClientProvider>"
    ],
    "description": "Next Setup React Query"
  },
  "Next Setup React Query2": {
    "prefix": "nxt-app-reactq2",
    "body": [
      "import \"@/styles/global.css\";",
      "import type { AppProps } from \"next/app\";",
      "import { useRef } from \"react\";",
      "import { QueryClient, QueryClientProvider } from \"react-query\";",
      "import { ReactQueryDevtools } from \"react-query/devtools\";",
      "",
      "export default function MyApp({ Component, pageProps }: AppProps) {",
      "  const client = useRef(new QueryClient());",
      "  return (",
      "    <QueryClientProvider client={client.current}>",
      "      <Component {...pageProps} />",
      "      <ReactQueryDevtools initialIsOpen={false} position=\"bottom-right\" />",
      "    </QueryClientProvider>",
      "  );",
      "}",
      ""
    ],
    "description": "Next Setup React Query2"
  },
  "Next custom document": {
    "prefix": "nxt-doc",
    "body": [
      "import React from \"react\";",
      "import Document, { Html, Head, Main, NextScript } from \"next/document\";",
      "",
      "export default class CustomDocument extends Document {",
      "  render() {",
      "    return (",
      "      <Html>",
      "        <Head></Head>",
      "        <body>",
      "          <Main />",
      "          <NextScript />",
      "        </body>",
      "      </Html>",
      "    );",
      "  }",
      "}",
      ""
    ],
    "description": "Next custom document"
  },
  "MUI AppBar hide On scroll": {
    "prefix": "mui-hideOnScroll",
    "body": [
      "type Props = {",
      "  children: React.ReactElement;",
      "};",
      "",
      "function HideOnScroll(props: Props) {",
      "  const { children } = props;",
      "  const trigger = useScrollTrigger();",
      "",
      "  return (",
      "    <Slide appear={false} direction=\"down\" in={!trigger}>",
      "      {children}",
      "    </Slide>",
      "  );",
      "}"
    ],
    "description": "MUI AppBar hide On scroll"
  },
  "MUF cus grid container": {
    "prefix": "muf-grid-cont",
    "body": [
      "import { Box } from \"@mui/material\";",
      "",
      "type MGridType = {",
      "  gridTempCol_xs?: string;",
      "  gridTempCol_sm?: string;",
      "  gridTempCol_md?: string;",
      "  gridTempRow_xs?: string;",
      "  gridTempRow_sm?: string;",
      "  gridTempRow_md?: string;",
      "  children: React.ReactNode;",
      "} & React.CSSProperties;",
      "",
      "function MGrid({",
      "  gridTempCol_xs,",
      "  gridTempCol_sm,",
      "  gridTempCol_md,",
      "  gridTempRow_xs,",
      "  gridTempRow_sm,",
      "  gridTempRow_md,",
      "  children,",
      "  ...rest",
      "}: MGridType) {",
      "  return (",
      "    <Box",
      "      sx={{",
      "        height: \"100vh\",",
      "        display: \"grid\",",
      "        gridTemplateColumns: {",
      "          xs: gridTempCol_xs,",
      "          sm: gridTempCol_sm,",
      "          md: gridTempCol_md,",
      "        },",
      "        gridTemplateRows: {",
      "          xs: gridTempRow_xs,",
      "          sm: gridTempRow_sm,",
      "          md: gridTempRow_md,",
      "        },",
      "        ...rest,",
      "      }}",
      "    >",
      "      {children}",
      "    </Box>",
      "  );",
      "}",
      "",
      "export default MGrid;",
      ""
    ],
    "description": "MUF cus grid container"
  },
  "MUF cus grid item": {
    "prefix": "muf-grid-item",
    "body": [
      "import { Box } from \"@mui/material\";",
      "",
      "type MGridItemType = {",
      "  xs?: { column?: string; row?: string };",
      "  sm?: { column?: string; row?: string };",
      "  md?: { column?: string; row?: string };",
      "  bgcolor?: React.CSSProperties[\"backgroundColor\"];",
      "  children?: React.ReactNode;",
      "};",
      "",
      "function MGridItem({",
      "  xs = { column: \"\", row: \"\" },",
      "  sm = { column: \"\", row: \"\" },",
      "  md = { column: \"\", row: \"\" },",
      "  bgcolor,",
      "  children,",
      "}: MGridItemType) {",
      "  return (",
      "    <Box",
      "      sx={{",
      "        backgroundColor: bgcolor,",
      "        gridColumn: {",
      "          xs: xs.column,",
      "          sm: sm.column,",
      "          md: md.column,",
      "        },",
      "        gridRow: {",
      "          xs: xs.row,",
      "          sm: sm.row,",
      "          md: md.row,",
      "        },",
      "      }}",
      "    >",
      "      {children}",
      "    </Box>",
      "  );",
      "}",
      "",
      "export default MGridItem;",
      ""
    ],
    "description": "MUF cus grid item"
  },
  "MUI Tabs": {
    "prefix": "mui-tabs",
    "body": [
      "const [value, setValue] = useState(\"1\");",
      "",
      "const handleChange = (e: React.SyntheticEvent, newVal: string) => {",
      "  setValue(newVal);",
      "};",
      "",
      "<TabContext value={value}>",
      "  <TabList",
      "    aria-label=\"Tab example\"",
      "    indicatorColor=\"secondary\"",
      "    color=\"secondary\"",
      "    onChange={handleChange}",
      "  >",
      "    <Tab value=\"1\" label=\"One\" />",
      "    <Tab value=\"2\" label=\"Two\" />",
      "    <Tab value=\"3\" label=\"Three\" />",
      "  </TabList>",
      "  <TabPanel value=\"1\">",
      "    <Typography>Oner</Typography>",
      "  </TabPanel>",
      "  <TabPanel value=\"2\">",
      "    <Typography>Twoer</Typography>",
      "  </TabPanel>",
      "  <TabPanel value=\"3\">",
      "    <Typography>Threer</Typography>",
      "  </TabPanel>",
      "</TabContext>"
    ],
    "description": "MUI Tabs"
  },
  "Hook Custom Controller Def": {
    "prefix": "hook-ctrlr-cus-def",
    "body": [
      "const Controller = ({ control, register, rules, render, name }: any) => {",
      "  const props = register(name, rules);",
      "",
      "  return render({",
      "    onChange: (e: any) =>",
      "      props.onChange({",
      "        target: {",
      "          name,",
      "          value: e,",
      "        },",
      "      }),",
      "    onBlur: props.onBlur,",
      "    name: props.name,",
      "  });",
      "};"
    ],
    "description": "Hook Custom Controller Def"
  },
  "Hook Custom Controller": {
    "prefix": "hook-ctrlr-cus",
    "body": [
      "<Controller",
      "  {...{",
      "    register,",
      "    control,",
      "    rules: {},",
      "    name: \"${1:Name}\",",
      "    render: (props: any) => {",
      "      return <${2:Component} {...props} />;",
      "    },",
      "  }}",
      "/>"
    ],
    "description": "Hook Custom Controller"
  },
  "UseState": {
    "prefix": "u-state",
    "body": ["const [${1:value}, set${2:value}] = useState(${3:defaultValue})"],
    "description": "UseState"
  },
  "Use Effect": {
    "prefix": "u-effect",
    "body": ["useEffect(() => {", "    ${2}", "}, [${1:states}])"],
    "description": "Use Effect"
  },
  "Auth123 Definition": {
    "prefix": "auth123",
    "body": [
      "// Auth1 is responsible for login & logout logic",
      "",
      "import { parseISO, add } from \"date-fns\";",
      "import { useLocation, useNavigate, Location } from \"react-router-dom\";",
      "",
      "function useAuth123(): {",
      "  location: Location;",
      "  logIn: (to_default: string) => void;",
      "  logOut: (logout_to: string) => void;",
      "  isExpired: () => boolean;",
      "  setMaxAge: (value: string) => void;",
      "  clearMaxAge: () => void;",
      "} {",
      "  const navigate = useNavigate();",
      "  const location = useLocation();",
      "",
      "  type LocationType = {",
      "    state: { from: any };",
      "  } & Location;",
      "",
      "  const nLocation = location as LocationType;",
      "  function logIn(to_default: string) {",
      "    const from = nLocation.state?.from?.pathname || to_default;",
      "    navigate(from, { replace: true });",
      "  }",
      "",
      "  function logOut(logout_to: string) {",
      "    navigate(logout_to, {",
      "      state: { from: location },",
      "      replace: true,",
      "    });",
      "  }",
      "",
      "  const isExpired = () => {",
      "    const maxAge = localStorage.getItem(\"Max-Age\");",
      "",
      "    const now = new Date();",
      "    const parseMax = parseISO(maxAge as string);",
      "",
      "    if (parseMax > now) {",
      "      return false;",
      "    } else {",
      "      localStorage.removeItem(\"Max-Age\");",
      "      return true;",
      "    }",
      "  };",
      "",
      "  const clearMaxAge = () => {",
      "    localStorage.removeItem(\"Max-Age\");",
      "  };",
      "",
      "  const setMaxAge = (value: string) => {",
      "    let time = value;",
      "    let unit = time.charAt(time.length - 1);",
      "    time = time.substring(0, time.length - 1);",
      "    let options: Duration = {};",
      "",
      "    switch (unit) {",
      "      case \"s\":",
      "        options.seconds = parseInt(time);",
      "        break;",
      "      case \"m\":",
      "        options.minutes = parseInt(time);",
      "        break;",
      "      case \"w\":",
      "        options.weeks = parseInt(time);",
      "        break;",
      "      default:",
      "        break;",
      "    }",
      "",
      "    let maxAge = add(new Date(), options).toISOString();",
      "",
      "    localStorage.setItem(\"Max-Age\", maxAge);",
      "  };",
      "",
      "  return { location, logIn, logOut, isExpired, setMaxAge, clearMaxAge };",
      "}",
      "",
      "export default useAuth123;",
      ""
    ],
    "description": "Auth123 Definition"
  },
  "Auth123 Use Refresh": {
    "prefix": "auth123-refresh",
    "body": [
      "function useRefresh() {",
      "  const refresh = async () => {",
      "      ",
      "  };",
      "",
      "  return refresh;",
      "}",
      "",
      "export default useRefresh;",
      ""
    ],
    "description": "Auth123 Use Refresh"
  },
  "Use Interceptor": {
    "prefix": "auth123-int",
    "body": [
      "import { AxiosError, AxiosRequestConfig } from \"axios\";",
      "import { useEffect, useState } from \"react\";",
      "import { axiosPrivate } from \"../api/axios\";",
      "import useRefresh from \"./useRefresh\";",
      "",
      "function useInterceptors() {",
      "  const [sent, setSent] = useState(false);",
      "  const refresh = useRefresh();",
      "",
      "  useEffect(() => {",
      "    const requestInterceptor = axiosPrivate.interceptors.request.use(",
      "      (config: AxiosRequestConfig) => {",
      "        if (!config?.headers?.Authorization) {",
      "          config.headers = {",
      "            Authorization: `Bearer \\${${1:accessToken}}`,",
      "          };",
      "        }",
      "        return config;",
      "      },",
      "      (error: AxiosError) => Promise.reject(error)",
      "    );",
      "",
      "    const responseInterceptor = axiosPrivate.interceptors.response.use(",
      "      (response) => response,",
      "      async (error: AxiosError) => {",
      "        if (error.response?.status === 403 && sent === false) {",
      "          setSent(true);",
      "          const refreshToken = await refresh();",
      "          error.config.headers = {",
      "            Authorization: `Bearer \\${refreshToken}`,",
      "          };",
      "",
      "          return axiosPrivate.request(error.config);",
      "        }",
      "        return Promise.reject(error);",
      "      }",
      "    );",
      "",
      "    return () => {",
      "      axiosPrivate.interceptors.request.eject(requestInterceptor);",
      "      axiosPrivate.interceptors.response.eject(responseInterceptor);",
      "    };",
      "  }, []);",
      "",
      "  return axiosPrivate;",
      "}",
      "",
      "export default useInterceptors;",
      ""
    ],
    "description": "Use Interceptor"
  },
  "Auth123 Loading Page": {
    "prefix": "auth123-loadPage",
    "body": [
      "export type PrivateLoadingAUType = {",
      "  status: string;",
      "};",
      "",
      "function PrivateLoadingAU({ status }: PrivateLoadingAUType) {",
      "  if (!!status === false) {",
      "    return (",
      "      <>",
      "        <h1>Loading ......</h1>",
      "        <p>Please wait</p>",
      "      </>",
      "    );",
      "  }",
      "  return (",
      "    <>",
      "      <h3>Unable to reach Server</h3>",
      "      <p>Please try refreshing page</p>",
      "    </>",
      "  );",
      "}",
      "",
      "export default PrivateLoadingAU;",
      ""
    ],
    "description": "Auth123 Loading Page"
  },
  "Auth123 Private Route & Role": {
    "prefix": "auth123-pr",
    "body": [
      "import { useEffect, useState } from \"react\";",
      "import { Navigate, Outlet } from \"react-router-dom\";",
      "import { isAxiosError } from \"../api/axios\";",
      "import useAuth123 from \"./useAuth123\";",
      "import useRefresh from \"./useRefresh\";",
      "import { PrivateLoadingAUType } from \"./PrivateLoadingAU\";",
      "",
      "////////////////////////////////////",
      "/// Default Unauthorized Path",
      "const unauth_Path = \"/unauthorized\";",
      "",
      "type PrivateRouteAUType = {",
      "  accepted_Roles: number[];",
      "  user_Roles: number[] | undefined;",
      "  loading_Comp: React.ComponentType<PrivateLoadingAUType>;",
      "};",
      "",
      "function PrivateRouteAU({",
      "  accepted_Roles,",
      "  user_Roles,",
      "  loading_Comp: Component,",
      "}: PrivateRouteAUType) {",
      "  const { location, logOut, isExpired } = useAuth123();",
      "  const isExp = isExpired();",
      "  const refresh = useRefresh();",
      "  const [errorStatus, setErrorStatus] = useState(\"\");",
      "",
      "  const roleMatch = (roles: number[], acceptedRoles: number[]) => {",
      "    return roles.find((role) => acceptedRoles.includes(role));",
      "  };",
      "",
      "  const runRefresh = async () => {",
      "    try {",
      "      const result = await refresh();",
      "    } catch (error) {",
      "      const err = isAxiosError(error);",
      "      setErrorStatus(err?.message as string);",
      "    }",
      "  };",
      "",
      "  useEffect(() => {",
      "    if (!!user_Roles?.length === false && isExp === false) {",
      "      runRefresh();",
      "    }",
      "",
      "    const handleFocus = () => {",
      "      if (isExpired()) logOut(\"/\");",
      "    };",
      "",
      "    window.addEventListener(\"focus\", handleFocus);",
      "",
      "    return () => {",
      "      window.removeEventListener(\"focus\", handleFocus);",
      "    };",
      "  }, [location]);",
      "",
      "  if (isExp) {",
      "    return <Navigate to=\"/\" state={{ from: location }} replace />;",
      "  } else {",
      "    if (!!user_Roles?.length) {",
      "      if (roleMatch(user_Roles as number[], accepted_Roles)) {",
      "        return <Outlet />;",
      "      }",
      "      return <Navigate to={unauth_Path} replace />;",
      "    }",
      "",
      "    return <Component status={errorStatus} />;",
      "  }",
      "}",
      "",
      "export default PrivateRouteAU;",
      ""
    ],
    "description": "Auth123 Private Route & Role"
  },
  "Auth123 Private Route": {
    "prefix": "auth123-p",
    "body": [
      "import { useEffect } from \"react\";",
      "import { Navigate, Outlet } from \"react-router-dom\";",
      "import useAuth123 from \"./useAuth123\";",
      "",
      "function PrivateRouteAU() {",
      "  const { location, logOut, isExpired } = useAuth123();",
      "",
      "  useEffect(() => {",
      "    const handleFocus = () => {",
      "      if (isExpired()) logOut(\"/\");",
      "    };",
      "",
      "    window.addEventListener(\"focus\", handleFocus);",
      "",
      "    return () => {",
      "      window.removeEventListener(\"focus\", handleFocus);",
      "    };",
      "  }, [location]);",
      "",
      "  const isExp = isExpired();",
      "",
      "  return !isExp ? (",
      "    <Outlet />",
      "  ) : (",
      "    <Navigate to=\"/\" state={{ from: location }} replace />",
      "  );",
      "}",
      "",
      "export default PrivateRouteAU;",
      ""
    ],
    "description": "Auth123 Private Route"
  },
  "MUseform": {
    "prefix": "u-form",
    "body": [
      "import { yupResolver } from \"@hookform/resolvers/yup\";",
      "import {",
      "  Control,",
      "  useForm,",
      "  UseFormRegister,",
      "  UseFormHandleSubmit,",
      "} from \"react-hook-form\";",
      "",
      "function ${1:useName}(schemaName: any): [",
      "  UseFormRegister<{}>,",
      "  UseFormHandleSubmit<{}>,",
      "  {},",
      "  Control<{}, any>",
      "] {",
      "  const {",
      "    register,",
      "    handleSubmit,",
      "    control,",
      "    formState: { errors },",
      "  } = useForm({",
      "    defaultValues: {},",
      "    resolver: yupResolver(schemaName),",
      "    mode: \"onBlur\",",
      "  });",
      "",
      "  return [register, handleSubmit, errors, control];",
      "}",
      "",
      "export default ${1:useName};",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// const [register, handleSubmit, errors, control] = ${1:useName}();"
    ],
    "description": "MUseform"
  },
  "MUseform Custom Resolver": {
    "prefix": "muf-resolver",
    "body": [
      "async (data, context) => {",
      "  console.log(context);",
      "  const { error, value: values } = schemaName.validate(data, {",
      "    abortEarly: false",
      "  });",
      "",
      "  return {",
      "    values: error ? {} : values,",
      "    errors: error",
      "      ? error.details.reduce((previous:any, currentError:any) => {",
      "          return {",
      "            ...previous,",
      "            [currentError.path[0]]: currentError",
      "          };",
      "        }, {})",
      "      : {}",
      "  };",
      "},"
    ],
    "description": "MUseform Custom Resolver"
  },
  "MU Theme Provider": {
    "prefix": "muf-themeprovider",
    "body": [
      "import React from \"react\";",
      "import { createTheme, ThemeProvider } from \"@mui/material\";",
      "",
      "type contextType = {",
      "  children: React.ReactNode;",
      "};",
      "",
      "const theme = createTheme({",
      "  typography: {",
      "    fontFamily: [\"\", \"\"].join(\",\"),",
      "  }",
      "});",
      "",
      "function ThemeContextProvider({ children }: contextType) {",
      "  return <ThemeProvider theme={theme}>{children}</ThemeProvider>;",
      "}",
      "",
      "export default ThemeContextProvider;"
    ],
    "description": "MU Theme Provider"
  },
  "MCheckGroup": {
    "prefix": "muf-checkBoxes",
    "body": [
      "import {",
      "  Checkbox,",
      "  FormControlLabel,",
      "  FormGroup,",
      "  FormLabel,",
      "  Stack,",
      "} from \"@mui/material\";",
      "",
      "type MCeeType = {",
      "  input: { key: string; value: string }[];",
      "  register: any;",
      "  name: string;",
      "  label?: string;",
      "};",
      "",
      "function ${1:Name}({ label, input, register, name }: MCeeType) {",
      "  return (",
      "    <FormGroup {...register(name)}>",
      "      {label && <FormLabel>{label}</FormLabel>}",
      "      <Stack direction=\"row\">",
      "        {input?.length > 0 &&",
      "          input?.map((checkbox) => (",
      "            <FormControlLabel",
      "              key={checkbox.key}",
      "              value={checkbox.value}",
      "              label={checkbox.key}",
      "              control={<Checkbox {...register(name)} />}",
      "            />",
      "          ))}",
      "      </Stack>",
      "    </FormGroup>",
      "  );",
      "}",
      "",
      "export default ${1:Name};",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// label field is optional",
      "// <${1:Name} {...{ register, name: \"\", input: [] }} />;",
      ""
    ],
    "description": "MCheckGroup"
  },
  "MRadioGroup": {
    "prefix": "muf-radioButtons",
    "body": [
      "import {",
      "  FormControlLabel,",
      "  FormLabel,",
      "  Radio,",
      "  RadioGroup,",
      "  Stack,",
      "} from \"@mui/material\";",
      "",
      "type MCeeType = {",
      "  input: { key: string; value: string }[];",
      "  register: any;",
      "  name: string;",
      "  label?: string;",
      "};",
      "",
      "function ${1:Name}({ label, input, register, name }: MCeeType) {",
      "  return (",
      "    <RadioGroup {...register(name)}>",
      "      {label && <FormLabel>{label}</FormLabel>}",
      "      <Stack direction=\"row\">",
      "        {input?.length > 0 &&",
      "          input?.map((radio) => (",
      "            <FormControlLabel",
      "              key={radio.key}",
      "              value={radio.value}",
      "              label={radio.key}",
      "              control={<Radio {...register(name)} />}",
      "            />",
      "          ))}",
      "      </Stack>",
      "    </RadioGroup>",
      "  );",
      "}",
      "",
      "export default ${1:Name};",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "{",
      "  /*  label is optional",
      "",
      "<${1:Name}",
      "  {...{",
      "    register,",
      "    name: \"\",",
      "    input: [],",
      "    label: \"\", ",
      "  }}",
      "/>; ",
      "",
      "*/",
      "}",
      ""
    ],
    "description": "MRadioGroup"
  },
  "MTextfield": {
    "prefix": "muf-textfield",
    "body": [
      "import { TextField, TextFieldProps } from \"@mui/material\";",
      "",
      "type TeeType = {",
      "  name: string;",
      "  label: string;",
      "  register: any;",
      "  errors: any;",
      "  type?: string;",
      "};",
      "",
      "function ${1:Name}({",
      "  name,",
      "  register,",
      "  errors,",
      "  label,",
      "  type,",
      "  ...rest",
      "}: TeeType & TextFieldProps) {",
      "  return (",
      "    <TextField",
      "      {...rest}",
      "      label={label}",
      "      type={type ? type : \"text\"}",
      "      {...register(name)}",
      "      error={!!errors[name]}",
      "      helperText={!!errors[name] && errors[name].message}",
      "    />",
      "  );",
      "}",
      "",
      "export default ${1:Name};",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "{/* ",
      "",
      "<${1:Name}",
      "  {...{",
      "    register,",
      "    errors,",
      "    name: \"\",",
      "    label: \"\",",
      "  }}",
      "/>; ",
      "",
      "*/}",
      ""
    ],
    "description": "MTextfield"
  },
  "MTextfield Use Tag": {
    "prefix": "u-muf-textfield",
    "body": [
      "<MTextfield",
      "    {...{",
      "    register,",
      "    errors,",
      "    name: \"${1:name}\",",
      "    label: \"${2:label}\",",
      "    }}",
      "/>"
    ],
    "description": "MTextfield Use Tag"
  },
  "MUF Controller": {
    "prefix": "muf-controller",
    "body": [
      "import { Controller } from \"react-hook-form\";",
      "",
      "type ${1:name}Type = {",
      "  control: any;",
      "  name: string;",
      "  label: string;",
      "  register: any;",
      "  errors: any;",
      "};",
      "",
      "function ${1:name}({",
      "  control,",
      "  name,",
      "  label,",
      "  errors,",
      "  register,",
      "}: ${1:name}Type) {",
      "  return (",
      "    <Controller",
      "      name={name}",
      "      control={control}",
      "      render={({ field }) => (",
      "",
      "      )}",
      "    />",
      "  );",
      "}",
      "",
      "export default ${1:name};",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "{/* ",
      "",
      "<${1:name}",
      "  {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"\",",
      "    label: \"\",",
      "  }}",
      "/>; ",
      "",
      "*/}",
      ""
    ],
    "description": "MUF Controller"
  },
  "MDateTime": {
    "prefix": "muf-dateTime",
    "body": [
      "import { Controller } from \"react-hook-form\";",
      "import { DatePicker, TimePicker } from \"@mui/x-date-pickers\";",
      "import { TextField, TextFieldProps } from \"@mui/material\";",
      "",
      "type MDateTimeType = {",
      "  control: any;",
      "  name: string;",
      "  label: string;",
      "  register: any;",
      "  errors: any;",
      "};",
      "",
      "function MDateTime({",
      "  control,",
      "  name,",
      "  label,",
      "  errors,",
      "  register,",
      "}: MDateTimeType & TextFieldProps) {",
      "  return (",
      "    <Controller",
      "      name={name}",
      "      control={control}",
      "      render={({ field }) => (",
      "        <${1|DatePicker,TimePicker|}",
      "          {...field}",
      "          label={label}",
      "          renderInput={(params:JSX.IntrinsicAttributes & TextFieldProps) => (",
      "            <TextField",
      "              {...params}",
      "              {...register(name)}",
      "              error={!!errors[name]}",
      "              helperText={!!errors[name] && errors[name].message}",
      "            />",
      "          )}",
      "        />",
      "      )}",
      "    />",
      "  );",
      "}",
      "",
      "export default MDateTime;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "// npm i @mui/x-date-pickers date-fns",
      "// Run 'muf-dateTime-provider' snippet and wrap tag around '<form>' tag then place '<MDateTime/>' inside '<form>'",
      "",
      "/*",
      "<MDateTime",
      "  {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"\",",
      "    label: \"\",",
      "  }}",
      "/>; ",
      "*/",
      ""
    ],
    "description": "MDateTime"
  },
  "MDateTime Tag": {
    "prefix": "u-muf-datetime",
    "body": [
      "<MDateTime",
      "  {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"${1:name}\",",
      "    label: \"${2:label}\",",
      "  }}",
      "/>"
    ],
    "description": "MDateTime Tag"
  },
  "MDateTime provider": {
    "prefix": "muf-dateTime-provider",
    "body": [
      "import { LocalizationProvider } from \"@mui/x-date-pickers\";",
      "import {AdapterDateFns} from \"@mui/x-date-pickers/AdapterDateFns\";",
      "",
      "<LocalizationProvider dateAdapter={AdapterDateFns}></LocalizationProvider>"
    ],
    "description": "MDateTime provider"
  },
  "MAutoComplete": {
    "prefix": "muf-autoc",
    "body": [
      "import { Autocomplete, TextField } from \"@mui/material\";",
      "import { MUFPropsType } from \"./MCustom\";",
      "",
      "function MAutoComplete(props: MUFPropsType) {",
      "  const handleChange = (e: any, b: string | null) => {",
      "    props.onChange && props.onChange(b);",
      "  };",
      "",
      "  return (",
      "    <>",
      "      <Autocomplete",
      "        onChange={handleChange}",
      "        options={props.input.map((item) => item.value)}",
      "        renderInput={(params) => <TextField {...params} label={props.label} />}",
      "      />",
      "    </>",
      "  );",
      "}",
      "",
      "export default MAutoComplete;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// Used with a custom component",
      "// Create MCustom.tsx",
      "// run snippet 'muf-custom' to create a custom component",
      "// assign this component to MCustom's component property",
      "// Optional parameter => [ label ]",
      "",
      "{",
      "  /* ",
      "  ",
      "  <MCustom",
      "    {...{",
      "      register,",
      "      errors,",
      "      control,",
      "      name: \"\",",
      "      label: \"\",",
      "      input: [{}],",
      "      rules: {},",
      "      component: MAutoComplete,",
      "    }}",
      "  />; ",
      "  ",
      "  */",
      "}",
      ""
    ],
    "description": "MAutoComplete"
  },
  "MSelect": {
    "prefix": "muf-select",
    "body": [
      "import { MenuItem, TextField } from \"@mui/material\";",
      "import React, { useState } from \"react\";",
      "import { MUFPropsType } from \"./MCustom\";",
      "",
      "function MSelect(props: MUFPropsType) {",
      "  const [value, setValue] = useState(props.defaultValue || \"\");",
      "",
      "  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {",
      "    setValue(e.target.value);",
      "    props.onChange && props.onChange(e.target.value);",
      "  };",
      "",
      "  return (",
      "    <>",
      "      <TextField",
      "        select",
      "        onChange={handleChange}",
      "        value={value}",
      "        label={props.label}",
      "      >",
      "        {!!props.input.length &&",
      "          props.input.map((item) => (",
      "            <MenuItem value={item.value} key={item.key}>",
      "              {item.key}",
      "            </MenuItem>",
      "          ))}",
      "      </TextField>",
      "    </>",
      "  );",
      "}",
      "",
      "export default MSelect;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// Used with a custom component",
      "// Create MCustom.tsx",
      "// run snippet 'muf-custom' to create a custom component",
      "// assign this component to MCustom's component property",
      "// Optional parameter => [",
      "//   label, defaultValue",
      "// ]",
      "// input: [{key:'', value:''}]",
      "",
      "{",
      "  /* ",
      "",
      "<MCustom",
      "  {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"\",",
      "    label: \"\",",
      "    input: [{}],",
      "    rules: {},",
      "    component: MSelect,",
      "  }}",
      "/>; ",
      "",
      "*/",
      "}",
      ""
    ],
    "description": "MSelect"
  },
  "MImage": {
    "prefix": "muf-img",
    "body": [
      "import { Box, Button, Typography } from \"@mui/material\";",
      "import { useEffect, useRef, useState } from \"react\";",
      "",
      "function MImage(props: any) {",
      "  const [error, setError] = useState(null);",
      "  const fileInput = useRef<HTMLInputElement>();",
      "",
      "  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {",
      "    if (!e.target.files) return;",
      "    const file = e.target.files[0];",
      "    props.onChange && props.onChange(file);",
      "  };",
      "",
      "  const handleClick = (e: React.MouseEvent) => {",
      "    fileInput.current?.click();",
      "  };",
      "",
      "  useEffect(() => {",
      "    if (props.errors[props.name]?.message)",
      "      setError(props.errors[props.name]?.message);",
      "    else setError(null);",
      "  }, [props.errors[props.name]]);",
      "",
      "  return (",
      "    <>",
      "      <Box",
      "        component={\"input\"}",
      "        type=\"file\"",
      "        ref={fileInput}",
      "        onChange={handleChange}",
      "        display=\"none\"",
      "      />",
      "      {error && <Typography color=\"error\">{error}</Typography>}",
      "      <Button onClick={handleClick}>Upload</Button>",
      "    </>",
      "  );",
      "}",
      "",
      "export default MImage;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// Used with a custom component",
      "// Create MCustom.tsx",
      "// run snippet 'muf-custom' to create a custom component",
      "// assign this component to MCustom's component property",
      "",
      "{",
      "  /* ",
      "",
      "<CustImage",
      "  {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"\",",
      "    rules: {},",
      "    component: MImage,",
      "  }}",
      "/>; ",
      "",
      "*/",
      "}",
      ""
    ],
    "description": "MImage"
  },
  "MCustom": {
    "prefix": "muf-custom",
    "body": [
      "/* eslint-disable @typescript-eslint/no-explicit-any */",
      "import React from \"react\";",
      "",
      "type ItemType = { key: string; value: any };",
      "",
      "export type MUFPropsType = {",
      "  name: string;",
      "  input: ItemType[];",
      "  label: string;",
      "  defaultValue: any;",
      "  onChange: (e: any) => void;",
      "  onBlur: (event: any) => Promise<any>;",
      "};",
      "",
      "type NewMCustomType = {",
      "  control: any;",
      "  register: any;",
      "  errors: object;",
      "  rules: object;",
      "  name: string;",
      "  label?: string;",
      "  input?: any[];",
      "  defaultValue?: any;",
      "  component: React.ComponentType<MUFPropsType>;",
      "};",
      "",
      "function MCustom({",
      "  register,",
      "  control,",
      "  name,",
      "  label,",
      "  errors,",
      "  rules,",
      "  input,",
      "  defaultValue,",
      "  component: Component,",
      "}: NewMCustomType) {",
      "  return (",
      "    <Controller",
      "      {...{",
      "        register,",
      "        control,",
      "        rules: {},",
      "        label,",
      "        name,",
      "        input,",
      "        defaultValue,",
      "        render: (props: MUFPropsType) => {",
      "          return <Component {...props} />;",
      "        },",
      "      }}",
      "    />",
      "  );",
      "}",
      "",
      "const Controller = ({",
      "  control,",
      "  register,",
      "  rules,",
      "  render,",
      "  name,",
      "  label,",
      "  input,",
      "  defaultValue,",
      "}: any) => {",
      "  const props = register(name, rules);",
      "",
      "  return render({",
      "    onChange: (e: any) =>",
      "      props.onChange({",
      "        target: {",
      "          name,",
      "          value: e,",
      "        },",
      "      }),",
      "    onBlur: props.onBlur,",
      "    name: props.name,",
      "    input: input || [],",
      "    label,",
      "    defaultValue,",
      "  });",
      "};",
      "",
      "export default MCustom;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// Assign a component to component field to integrate",
      "// Label, Input and defaultValue are optional parameters",
      "{",
      "  /* ",
      "",
      "<MCustom",
      "    {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"\",",
      "    rules: {},",
      "    component:",
      "    }}",
      "/> ",
      "",
      "*/",
      "}",
      ""
    ],
    "description": "MCustom"
  },
  "MCustomUse Tag": {
    "prefix": "u-muf-custom",
    "body": [
      "<MCustom",
      "  {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"${1:name}\",",
      "    label: \"${2:label}\",",
      "    input: options,",
      "    rules: {},",
      "    component: ${3:componentName},",
      "  }}",
      "/>"
    ],
    "description": "MCustomUse Tag"
  },
  "MSwitch": {
    "prefix": "muf-switch",
    "body": [
      "import React from \"react\";",
      "import { Control, UseFormRegister } from \"react-hook-form\";",
      "",
      "type ItemType = { key: string; value: any };",
      "",
      "export type MUFPropsType = {",
      "  name: string;",
      "  input: ItemType[];",
      "  label: string;",
      "  defaultValue: any;",
      "  onChange: (e: any) => void;",
      "  onBlur: (event: any) => Promise<any>;",
      "};",
      "",
      "type NewMCustomType = {",
      "  control: any;",
      "  register: any;",
      "  errors: {};",
      "  rules: {};",
      "  name: string;",
      "  label?: string;",
      "  input?: any[];",
      "  defaultValue?: any;",
      "  component: React.ComponentType<MUFPropsType>;",
      "};",
      "",
      "function MCustom({",
      "  register,",
      "  control,",
      "  name,",
      "  label,",
      "  errors,",
      "  rules,",
      "  input,",
      "  defaultValue,",
      "  component: Component,",
      "}: NewMCustomType) {",
      "  return (",
      "    <Controller",
      "      {...{",
      "        register,",
      "        control,",
      "        rules: {},",
      "        label,",
      "        name,",
      "        input,",
      "        defaultValue,",
      "        render: (props: MUFPropsType) => {",
      "          return <Component {...props} />;",
      "        },",
      "      }}",
      "    />",
      "  );",
      "}",
      "",
      "const Controller = ({",
      "  control,",
      "  register,",
      "  rules,",
      "  render,",
      "  name,",
      "  label,",
      "  input,",
      "  defaultValue,",
      "}: any) => {",
      "  const props = register(name, rules);",
      "",
      "  return render({",
      "    onChange: (e: any) =>",
      "      props.onChange({",
      "        target: {",
      "          name,",
      "          value: e,",
      "        },",
      "      }),",
      "    onBlur: props.onBlur,",
      "    name: props.name,",
      "    input: input || [],",
      "    label,",
      "    defaultValue,",
      "  });",
      "};",
      "",
      "export default MCustom;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "// Assign a component to component field to integrate",
      "// Label, Input and defaultValue are optional parameters",
      "{",
      "  /* ",
      "",
      "<MCustom",
      "    {...{",
      "    register,",
      "    errors,",
      "    control,",
      "    name: \"\",",
      "    rules: {},",
      "    component: MSwitch",
      "    }}",
      "/> ",
      "",
      "*/",
      "}",
      ""
    ],
    "description": "MSwitch"
  },
  "MMenu": {
    "prefix": "muf-menu",
    "body": [
      "import { Button, ButtonProps, Menu } from \"@mui/material\";",
      "import { useState, ReactNode } from \"react\";",
      "",
      "type MMenuType = {",
      "  id: string;",
      "  title: string;",
      "  children: ReactNode;",
      "  anchorOrigin?: {",
      "    vertical: \"center\" | \"bottom\" | \"top\";",
      "    horizontal: \"center\" | \"right\" | \"left\";",
      "  };",
      "  transformOrigin?: {",
      "    vertical: \"center\" | \"bottom\" | \"top\";",
      "    horizontal: \"center\" | \"right\" | \"left\";",
      "  };",
      "} & ButtonProps;",
      "",
      "function MMenu({",
      "  id,",
      "  title,",
      "  children,",
      "  anchorOrigin = { vertical: \"bottom\", horizontal: \"left\" },",
      "  transformOrigin = { vertical: \"top\", horizontal: \"left\" },",
      "  ...rest",
      "}: MMenuType) {",
      "  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);",
      "  const open = Boolean(anchorEl);",
      "",
      "  const handleClose = () => {",
      "    setAnchorEl(null);",
      "  };",
      "",
      "  const handleOpen = (e: React.MouseEvent<any>) => {",
      "    setAnchorEl(e.currentTarget);",
      "  };",
      "",
      "  return (",
      "    <>",
      "      <Button",
      "        id={id}",
      "        onClick={handleOpen}",
      "        aria-controls={open ? `id_menu` : undefined}",
      "        aria-haspopup=\"true\"",
      "        aria-expanded={open ? \"true\" : undefined}",
      "        {...rest}",
      "      >",
      "        {title}",
      "      </Button>",
      "",
      "      <Menu",
      "        id={`id_menu`}",
      "        anchorEl={anchorEl}",
      "        open={open}",
      "        MenuListProps={{",
      "          \"aria-labelledby\": id,",
      "        }}",
      "        onClose={handleClose}",
      "        anchorOrigin={{ ...anchorOrigin }}",
      "        transformOrigin={{ ...transformOrigin }}",
      "      >",
      "        {children}",
      "      </Menu>",
      "    </>",
      "  );",
      "}",
      "",
      "export default MMenu;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "/// Optional parameter => [ anchorOrigin, transformOrigin ]",
      "",
      "{",
      "  /* ",
      "",
      "<MMenu id=\"\" title=\"\">",
      "  <MenuItem onClick={() => console.log(\"close one\")}>One</MenuItem>",
      "  <MenuItem onClick={() => console.log(\"close two\")}>Two</MenuItem>",
      "</MMenu> ",
      "",
      "*/",
      "}",
      ""
    ],
    "description": "MMenu"
  },
  "MTable": {
    "prefix": "muf-table",
    "body": [
      "import {",
      "  Paper,",
      "  Table,",
      "  TableBody,",
      "  TableCell,",
      "  TableContainer,",
      "  TableHead,",
      "  TablePagination,",
      "  TableRow,",
      "} from \"@mui/material\";",
      "import React, { useState } from \"react\";",
      "",
      "type MTableType = {",
      "  columns: string[];",
      "  rows: any[];",
      "  pagination: number[];",
      "};",
      "",
      "function MTable({ columns, rows, pagination }: MTableType) {",
      "  const [page, setPage] = useState(0);",
      "  const [rowsPerPage, setRowsPerPage] = useState(pagination[0]);",
      "",
      "  const handleChangePage = (e: any, newPage: number) => {",
      "    setPage(newPage);",
      "  };",
      "",
      "  const handleChangeRowsPerPage = (e: any) => {",
      "    setRowsPerPage(e.target.value);",
      "  };",
      "  return (",
      "    <TableContainer component={Paper} sx={{ borderRadius: 2 }}>",
      "      <Table sx={{ minWidth: 650 }}>",
      "        <TableHead>",
      "          <TableRow>",
      "            {columns.length > 0 &&",
      "              columns.map((cell, i) => (",
      "                <React.Fragment key={i}>",
      "                  <TableCell>{cell}</TableCell>",
      "                </React.Fragment>",
      "              ))}",
      "          </TableRow>",
      "        </TableHead>",
      "        <TableBody>",
      "          {rows",
      "            .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)",
      "            .map((cell, i) => (",
      "              <TableRow key={i}>",
      "                <TableCell>{cell.name}</TableCell>",
      "                <TableCell>{cell.sex}</TableCell>",
      "                <TableCell>{cell.age}</TableCell>",
      "              </TableRow>",
      "            ))}",
      "        </TableBody>",
      "      </Table>",
      "      <TablePagination",
      "        rowsPerPageOptions={pagination}",
      "        component=\"div\"",
      "        count={rows.length}",
      "        page={page}",
      "        rowsPerPage={rowsPerPage}",
      "        onPageChange={handleChangePage}",
      "        onRowsPerPageChange={handleChangeRowsPerPage}",
      "      />",
      "    </TableContainer>",
      "  );",
      "}",
      "",
      "export default MTable;",
      "",
      "////////////////////////////////////",
      "/// Usage",
      "",
      "{/* ",
      "",
      "<MMenu",
      "  pagination={[5, 10, 15]}",
      "  columns={['','']}",
      "  rows={[{},{}]}",
      "/>; ",
      "",
      "*/}",
      ""
    ],
    "description": "MTable"
  }
}
